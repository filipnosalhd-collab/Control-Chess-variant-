<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <title>Control Chess</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20viewBox%3D%220%200%2032%2032%22%3E%3Crect%20width%3D%2232%22%20height%3D%2232%22%20rx%3D%226%22%20fill%3D%22%231a1a1e%22/%3E%3Ctext%20x%3D%2216%22%20y%3D%2224%22%20text-anchor%3D%22middle%22%20font-size%3D%2222%22%20font-family%3D%22serif%22%3E%E2%99%9B%3C/text%3E%3C/svg%3E"
    />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Crimson+Pro:wght@400;600&display=swap");
      :root {
        --bg: #0d0d0f;
        --sur: #141416;
        --pan: #1a1a1e;
        --brd: #2a2a32;
        --gold: #c9a84c;
        --gld2: #f0d080;
        --lt: #e8d5b0;
        --dk: #7a5c3a;
        --txt: #e8e0d0;
        --dim: #7a7060;
        --acc: #4a9eff;
        --red: #e53935;
        --grn: #4caf50;
        --sq: clamp(
          44px,
          min(calc((100vw - 330px) / 8), calc((100vh - 140px) / 8)),
          80px
        );
        --lbl: 20px;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        height: 100%;
        background: var(--bg);
        color: var(--txt);
        font-family: "Crimson Pro", serif;
        overflow: hidden;
      }
      body {
        display: flex;
        flex-direction: column;
      }
      header {
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 12px;
        border-bottom: 1px solid var(--brd);
        background: var(--sur);
        gap: 8px;
      }
      .logo {
        font-family: "Cinzel", serif;
        font-size: 1rem;
        font-weight: 900;
        color: var(--gold);
        white-space: nowrap;
      }
      .logo em {
        color: var(--dim);
        font-weight: 400;
        font-style: normal;
        font-size: 0.8em;
      }
      .hright {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-shrink: 0;
      }
      .htip {
        font-size: 0.6rem;
        color: var(--dim);
      }
      .hbtn {
        padding: 4px 10px;
        border: 1px solid var(--brd);
        border-radius: 5px;
        background: var(--sur);
        color: var(--txt);
        font-size: 0.62rem;
        font-family: "Cinzel", serif;
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.18s;
      }
      .hbtn:hover {
        border-color: var(--gold);
        color: var(--gold);
      }
      .hbtn.gold {
        background: var(--gold);
        color: #111;
        border-color: var(--gold);
      }
      .hbtn.gold:hover {
        background: var(--gld2);
      }
      .online-dot {
        display: inline-block;
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background: var(--grn);
        margin-right: 4px;
        animation: pulse-g 2s infinite;
      }
      @keyframes pulse-g {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.4;
        }
      }
      .wrap {
        flex: 1;
        display: flex;
        min-height: 0;
        overflow: hidden;
      }
      .evbar {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        width: 14px;
        flex-shrink: 0;
        align-self: center;
        background: transparent;
        border: none;
        position: relative;
        user-select: none;
        margin-right: 2px;
      }
      .evtrack {
        width: 100%;
        position: relative;
        overflow: hidden;
        border-radius: 3px;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      .evb {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background: #262421;
        transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .evw {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: #f0d9b5;
        transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .evlbl-w {
        position: absolute;
        bottom: 3px;
        left: 0;
        right: 0;
        text-align: center;
        font-family: "Cinzel", serif;
        font-size: 0.38rem;
        font-weight: 900;
        color: #1a1a1a;
        pointer-events: none;
        z-index: 2;
        line-height: 1;
      }
      .evlbl-b {
        position: absolute;
        top: 3px;
        left: 0;
        right: 0;
        text-align: center;
        font-family: "Cinzel", serif;
        font-size: 0.38rem;
        font-weight: 900;
        color: #f0d9b5;
        pointer-events: none;
        z-index: 2;
        line-height: 1;
      }
      .evsc {
        position: absolute;
        left: 18px;
        background: #111;
        border: 1px solid #333;
        border-radius: 4px;
        padding: 2px 6px;
        font-family: "Cinzel", serif;
        font-size: 0.58rem;
        color: #c9a84c;
        font-weight: 700;
        white-space: nowrap;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.15s;
        top: 50%;
        transform: translateY(-50%);
      }
      .evbar:hover .evsc {
        opacity: 1;
      }
      .evmid {
        position: absolute;
        left: 0;
        right: 0;
        top: 50%;
        height: 1px;
        background: rgba(255, 255, 255, 0.12);
        z-index: 3;
        pointer-events: none;
      }
      .center {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 5px;
        padding: 10px;
        min-width: 0;
        overflow: hidden;
      }
      .pinfo {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: calc(var(--sq) * 8 + var(--lbl) * 2 + 4px);
        max-width: 100%;
        padding: 3px 8px;
        background: var(--pan);
        border: 1px solid var(--brd);
        border-radius: 5px;
        transition:
          opacity 0.2s,
          transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .pnm {
        font-family: "Cinzel", serif;
        font-size: 0.68rem;
        font-weight: 700;
      }
      .caps {
        font-size: 0.72rem;
        display: flex;
        gap: 1px;
        flex-wrap: wrap;
        max-width: 180px;
      }
      .psc {
        font-family: "Cinzel", serif;
        font-size: 0.65rem;
        color: var(--dim);
      }
      .timer {
        font-family: "Cinzel", serif;
        font-size: 1rem;
        font-weight: 900;
        color: var(--gold);
        letter-spacing: 0.04em;
        min-width: 60px;
        text-align: right;
        display: none;
      }
      .timer.low {
        color: var(--red);
        animation: pulse-r 0.8s infinite;
      }
      @keyframes pulse-r {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }
      .timer.active {
        color: var(--gold);
      }
      .timer.critical {
        color: var(--red) !important;
        font-size: 1.1rem;
      }
      .bwrap {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-shrink: 0;
        transition: transform 0.45s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .bwrap.flipped {
        transform: rotate(180deg);
      }
      .bwrap.flipped .blbl {
        transform: rotate(180deg);
      }
      .bwrap.flipped .pc {
        transform: rotate(180deg);
      }
      .bwrap.flipped .friz {
        transform: rotate(180deg);
      }
      .bwrap.flipped .dot::after {
        transform: rotate(180deg);
      }
      /* Pre-move highlight ‚Äî chess.com style */
      .pre {
        background: rgba(255, 200, 0, 0.35) !important;
      }
      .pre.lt {
        background: rgba(255, 200, 0, 0.4) !important;
      }
      .pre.dk {
        background: rgba(255, 200, 0, 0.3) !important;
      }
      /* premove-from: darker orange overlay on source */
      .premove-from.lt {
        background: #f6a623cc !important;
      }
      .premove-from.dk {
        background: #d4870099 !important;
      }
      /* premove-to: bright yellow-orange on destination */
      .premove-to.lt {
        background: #f6d022cc !important;
      }
      .premove-to.dk {
        background: #e6b800aa !important;
      }
      .b-top,
      .b-bot {
        display: flex;
        margin-left: var(--lbl);
        height: var(--lbl);
      }
      .b-mid {
        display: flex;
        position: relative;
      }
      .b-left,
      .b-right {
        width: var(--lbl);
        display: flex;
        flex-direction: column;
      }
      .blbl {
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Cinzel", serif;
        font-size: 0.72rem;
        font-weight: 700;
        color: var(--dim);
        flex-shrink: 0;
      }
      .blbl.f {
        width: var(--sq);
        height: var(--lbl);
      }
      .blbl.r {
        width: var(--lbl);
        height: var(--sq);
      }
      .board {
        display: grid;
        grid-template-columns: repeat(8, var(--sq));
        grid-template-rows: repeat(8, var(--sq));
        border: 2px solid var(--gold);
        box-shadow:
          0 0 24px rgba(201, 168, 76, 0.15),
          0 8px 32px rgba(0, 0, 0, 0.8);
        flex-shrink: 0;
      }
      .sq {
        width: var(--sq);
        height: var(--sq);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        cursor: pointer;
        user-select: none;
        touch-action: none;
      }
      .lt {
        background: var(--lt);
      }
      .dk {
        background: var(--dk);
      }
      .sel {
        background: #aad455 !important;
      }
      .lm {
        background: rgba(205, 210, 106, 0.55) !important;
      }
      .lm.dk {
        background: rgba(170, 175, 80, 0.65) !important;
      }
      .chk {
        background: rgba(220, 30, 30, 0.7) !important;
      }
      .frz {
        background: rgba(74, 158, 255, 0.22) !important;
      }
      .dot::after {
        content: "";
        position: absolute;
        width: 33%;
        height: 33%;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.18);
        pointer-events: none;
      }
      .cring::after {
        content: "";
        position: absolute;
        inset: 5%;
        border-radius: 50%;
        border: 3px solid rgba(0, 0, 0, 0.22);
        pointer-events: none;
      }
      /* Premove possible squares ‚Äî orange dots/rings like chess.com */
      .pre-dot::after {
        content: "";
        position: absolute;
        width: 33%;
        height: 33%;
        border-radius: 50%;
        background: rgba(240, 120, 0, 0.55);
        pointer-events: none;
      }
      .pre-cring::after {
        content: "";
        position: absolute;
        inset: 5%;
        border-radius: 50%;
        border: 3px solid rgba(240, 120, 0, 0.55);
        pointer-events: none;
      }
      .pc {
        font-size: calc(var(--sq) * 0.72);
        line-height: 1;
        position: relative;
        z-index: 2;
        pointer-events: none;
      }
      .pw {
        color: #fff;
        filter: drop-shadow(0 0 1px #000) drop-shadow(1px 1px 0 #000);
      }
      .pb {
        color: #1a0a00;
        filter: drop-shadow(0 0 1px rgba(255, 255, 255, 0.9));
      }
      .friz {
        position: absolute;
        top: 0;
        right: 1px;
        font-size: calc(var(--sq) * 0.19);
        z-index: 3;
        pointer-events: none;
      }
      .pc.dim {
        opacity: 0.15;
      }
      .rpanel {
        width: 220px;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        gap: 5px;
        padding: 5px;
        overflow-y: auto;
        background: var(--bg);
      }
      .rpanel::-webkit-scrollbar {
        width: 2px;
      }
      .rpanel::-webkit-scrollbar-thumb {
        background: var(--brd);
        border-radius: 1px;
      }
      .card {
        background: var(--pan);
        border: 1px solid var(--brd);
        border-radius: 7px;
        overflow: hidden;
      }
      .chdr {
        padding: 6px 10px;
        background: var(--sur);
        border-bottom: 1px solid var(--brd);
        font-family: "Cinzel", serif;
        font-size: 0.6rem;
        font-weight: 700;
        color: var(--gold);
        letter-spacing: 0.1em;
        text-transform: uppercase;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .chdr:hover {
        background: rgba(255, 255, 255, 0.04);
      }
      .arr {
        font-style: normal;
        font-size: 0.56rem;
        color: var(--dim);
        transition: transform 0.22s;
      }
      .chdr.cl .arr {
        transform: rotate(-90deg);
      }
      .cbody {
        overflow: hidden;
        transition:
          max-height 0.28s,
          opacity 0.22s;
        max-height: 400px;
        opacity: 1;
      }
      .cbody.cl {
        max-height: 0;
        opacity: 0;
      }
      .sbody {
        padding: 7px 10px;
        font-size: 0.76rem;
        min-height: 32px;
        display: flex;
        align-items: center;
        gap: 4px;
        flex-wrap: wrap;
        line-height: 1.4;
      }
      .tdot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        flex-shrink: 0;
      }
      .thk {
        display: none;
        padding: 4px 10px;
        color: var(--acc);
        font-size: 0.68rem;
        align-items: center;
        gap: 4px;
      }
      .thk.on {
        display: flex;
      }
      .d {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: var(--acc);
        animation: bnc 1.2s infinite;
      }
      .d:nth-child(2) {
        animation-delay: 0.2s;
      }
      .d:nth-child(3) {
        animation-delay: 0.4s;
      }
      @keyframes bnc {
        0%,
        80%,
        100% {
          transform: translateY(0);
          opacity: 0.4;
        }
        40% {
          transform: translateY(-4px);
          opacity: 1;
        }
      }
      .rbody {
        padding: 6px 10px;
        font-size: 0.8rem;
        font-weight: 700;
        min-height: 28px;
        display: flex;
        align-items: center;
        gap: 4px;
        flex-wrap: wrap;
      }
      .mbody {
        padding: 5px 10px;
        max-height: 120px;
        overflow-y: auto;
        font-size: 0.72rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1px;
        line-height: 1.5;
      }
      .mn {
        color: var(--dim);
      }
      .mw {
        color: var(--txt);
      }
      .mb2 {
        color: var(--dim);
      }
      .dwrap {
        display: flex;
        gap: 3px;
        padding: 5px 10px;
        flex-wrap: wrap;
      }
      .lb {
        padding: 2px 7px;
        border: 1px solid var(--brd);
        border-radius: 14px;
        background: transparent;
        color: var(--dim);
        font-size: 0.64rem;
        cursor: pointer;
        font-family: "Crimson Pro", serif;
        transition: all 0.18s;
      }
      .lb.on {
        border-color: var(--gold);
        color: var(--gold);
        background: rgba(201, 168, 76, 0.1);
      }
      .rls {
        padding: 7px 10px;
        font-size: 0.68rem;
        color: var(--dim);
        line-height: 1.55;
      }
      .rl {
        display: flex;
        gap: 5px;
        margin-bottom: 4px;
      }
      .ri {
        color: var(--gold);
        flex-shrink: 0;
      }
      .brow {
        display: flex;
        gap: 5px;
        padding: 5px 10px;
      }
      .btn {
        flex: 1;
        padding: 5px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Cinzel", serif;
        font-size: 0.6rem;
        font-weight: 700;
        letter-spacing: 0.03em;
        transition: all 0.18s;
      }
      .bgd {
        background: var(--gold);
        color: #111;
      }
      .bgd:hover {
        background: var(--gld2);
      }
      .bsc {
        background: var(--sur);
        color: var(--txt);
        border: 1px solid var(--brd);
      }
      .bsc:hover {
        border-color: var(--gold);
        color: var(--gold);
      }
      /* move rating colors */
      .br {
        color: #00e5ff;
      }
      .gr {
        color: #e040fb;
      }
      .be {
        color: #69f0ae;
      }
      .ex {
        color: #b2ff59;
      }
      .go {
        color: #fff176;
      }
      .ok {
        color: #a5d6a7;
      }
      .in {
        color: #ffcc02;
      }
      .mi {
        color: #ff7043;
      }
      .bl {
        color: #ff1744;
      }
      .ct {
        color: #ff6d00;
      }
      .ck {
        color: var(--red);
      }
      #mbar {
        display: none;
        flex-shrink: 0;
        background: var(--pan);
        border-top: 1px solid var(--brd);
        padding: 3px 5px;
        gap: 3px;
        flex-direction: column;
      }
      .mr {
        display: flex;
        gap: 3px;
        align-items: center;
      }
      .mst {
        flex: 1;
        font-family: "Cinzel", serif;
        font-size: 0.6rem;
        color: var(--txt);
      }
      .mev {
        font-family: "Cinzel", serif;
        font-size: 0.6rem;
        color: var(--gold);
        font-weight: 700;
        min-width: 30px;
        text-align: right;
      }
      .mrt {
        font-size: 0.6rem;
        flex: 1;
      }
      .mthk {
        display: none;
        align-items: center;
        gap: 3px;
        color: var(--acc);
        font-size: 0.58rem;
      }
      .mthk.on {
        display: flex;
      }
      .mpls {
        display: flex;
        gap: 2px;
        overflow-x: auto;
        flex: 1;
      }
      .mpls::-webkit-scrollbar {
        display: none;
      }
      .mpl {
        padding: 1px 6px;
        border-radius: 14px;
        border: 1px solid var(--brd);
        background: transparent;
        color: var(--dim);
        font-size: 0.56rem;
        cursor: pointer;
        white-space: nowrap;
        font-family: "Crimson Pro", serif;
        flex-shrink: 0;
        transition: all 0.18s;
      }
      .mpl.on {
        border-color: var(--gold);
        color: var(--gold);
        background: rgba(201, 168, 76, 0.1);
      }
      .mbtn {
        padding: 2px 7px;
        border: 1px solid var(--brd);
        border-radius: 4px;
        background: var(--sur);
        color: var(--dim);
        font-size: 0.58rem;
        font-family: "Cinzel", serif;
        cursor: pointer;
        white-space: nowrap;
      }
      .mbtn.mgold {
        background: var(--gold);
        color: #111;
        border-color: var(--gold);
      }
      .mbtn.on {
        border-color: var(--gold);
        color: var(--gold);
        background: rgba(201, 168, 76, 0.15);
      }
      .modal {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 500;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(2px);
      }
      .modal.on {
        display: flex;
      }
      .mbox {
        background: var(--pan);
        border: 1px solid var(--gold);
        border-radius: 10px;
        padding: 20px 24px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        max-width: 90vw;
      }
      .mbt {
        font-family: "Cinzel", serif;
        font-size: 0.95rem;
        color: var(--gold);
        font-weight: 700;
      }
      .mbs {
        font-size: 0.78rem;
        color: var(--dim);
        text-align: center;
        max-width: 240px;
      }
      .mbbs {
        display: flex;
        gap: 7px;
      }
      .mbb {
        padding: 6px 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Cinzel", serif;
        font-size: 0.64rem;
        font-weight: 700;
        transition: all 0.18s;
      }
      .mbb.y {
        background: var(--gold);
        color: #111;
      }
      .mbb.y:hover {
        background: var(--gld2);
      }
      .mbb.n {
        background: var(--sur);
        color: var(--txt);
        border: 1px solid var(--brd);
      }
      .mbb.n:hover {
        border-color: var(--gold);
        color: var(--gold);
      }
      .pp {
        cursor: pointer;
        padding: 5px;
        border-radius: 7px;
        font-size: 2.2rem;
        transition: background 0.18s;
        line-height: 1;
      }
      .pp:hover {
        background: rgba(201, 168, 76, 0.2);
      }
      .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: var(--pan);
        border: 1px solid var(--gold);
        border-radius: 9px;
        padding: 12px 16px;
        font-family: "Cinzel", serif;
        box-shadow: 0 0 26px rgba(201, 168, 76, 0.2);
        transform: translateY(14px);
        opacity: 0;
        transition: all 0.32s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        z-index: 600;
        display: flex;
        flex-direction: column;
        gap: 7px;
        min-width: 190px;
        pointer-events: none;
      }
      .toast.on {
        transform: translateY(0);
        opacity: 1;
        pointer-events: auto;
      }
      .tti {
        font-size: 0.95rem;
        font-weight: 900;
        color: var(--gold);
      }
      .tsu {
        font-size: 0.75rem;
        color: var(--dim);
        font-family: "Crimson Pro", serif;
      }
      .tbtnrow {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }
      .tbtn {
        padding: 4px 11px;
        background: var(--gold);
        color: #111;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Cinzel", serif;
        font-size: 0.6rem;
        font-weight: 700;
      }
      .tbtn:hover {
        background: var(--gld2);
      }
      .tbtn.sec {
        background: var(--sur);
        color: var(--txt);
        border: 1px solid var(--brd);
      }
      .tbtn.sec:hover {
        border-color: var(--gold);
        color: var(--gold);
      }
      .lobby {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 700;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
      }
      .lobby.on {
        display: flex;
      }
      .lbox {
        background: var(--pan);
        border: 1px solid var(--gold);
        border-radius: 14px;
        padding: 24px 28px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        width: min(440px, 95vw);
        max-height: 95vh;
        overflow-y: auto;
      }
      .lbox::-webkit-scrollbar {
        width: 3px;
      }
      .lbox::-webkit-scrollbar-thumb {
        background: var(--brd);
      }
      .ltitle {
        font-family: "Cinzel", serif;
        font-size: 1.05rem;
        color: var(--gold);
        font-weight: 900;
        text-align: center;
      }
      .lsec {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .llabel {
        font-family: "Cinzel", serif;
        font-size: 0.6rem;
        color: var(--dim);
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }
      .linput {
        background: var(--sur);
        border: 1px solid var(--brd);
        border-radius: 6px;
        padding: 7px 10px;
        font-size: 0.82rem;
        color: var(--txt);
        font-family: "Crimson Pro", serif;
        width: 100%;
        outline: none;
        transition: border-color 0.18s;
      }
      .linput:focus {
        border-color: var(--gold);
      }
      .llink {
        background: var(--sur);
        border: 1px solid var(--brd);
        border-radius: 6px;
        padding: 7px 10px;
        font-size: 0.68rem;
        color: var(--acc);
        word-break: break-all;
        cursor: pointer;
        font-family: monospace;
        transition: border-color 0.18s;
        user-select: all;
      }
      .llink:hover {
        border-color: var(--acc);
      }
      .lplayers {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
      }
      .lplayer {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3px;
        padding: 10px 14px;
        border: 1px solid var(--brd);
        border-radius: 8px;
        min-width: 110px;
        flex: 1;
      }
      .lplayer.joined {
        border-color: var(--gold);
        background: rgba(201, 168, 76, 0.07);
      }
      .lpnm {
        font-family: "Cinzel", serif;
        font-size: 0.78rem;
        font-weight: 700;
        text-align: center;
      }
      .lpst {
        font-size: 0.6rem;
        color: var(--dim);
      }
      .lkick {
        font-size: 0.58rem;
        color: var(--red);
        cursor: pointer;
        border: none;
        background: none;
        font-family: "Cinzel", serif;
        padding: 1px 4px;
        margin-top: 1px;
      }
      .lkick:hover {
        text-decoration: underline;
      }
      .lvs {
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        color: var(--dim);
        flex-shrink: 0;
      }
      .tpicker {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        justify-content: center;
      }
      .tpill {
        padding: 3px 9px;
        border: 1px solid var(--brd);
        border-radius: 14px;
        background: transparent;
        color: var(--dim);
        font-size: 0.68rem;
        cursor: pointer;
        font-family: "Crimson Pro", serif;
        transition: all 0.18s;
      }
      .tpill.on {
        border-color: var(--gold);
        color: var(--gold);
        background: rgba(201, 168, 76, 0.1);
      }
      .lopts {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
      }
      .ltoggle {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 0.72rem;
        color: var(--dim);
        cursor: pointer;
      }
      .ltoggle input {
        accent-color: var(--gold);
      }
      .lbtnrow {
        display: flex;
        gap: 7px;
      }
      .lcstat {
        font-size: 0.6rem;
        color: var(--dim);
        text-align: center;
        min-height: 16px;
      }
      .lmsg {
        font-size: 0.7rem;
        color: var(--acc);
        text-align: center;
        min-height: 16px;
      }
      @keyframes pfly {
        0% {
          opacity: 1;
          transform: translateY(0) rotate(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-600px) rotate(720deg);
        }
      }
      @keyframes cfall {
        0% {
          opacity: 1;
          transform: translateY(-60px) rotate(0);
        }
        100% {
          opacity: 0;
          transform: translateY(110vh) rotate(720deg);
        }
      }
      .cfti {
        position: fixed;
        top: -20px;
        font-size: 1.1rem;
        z-index: 800;
        pointer-events: none;
        animation: cfall 2s ease-in forwards;
      }
      .ghost {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        line-height: 1;
        transform: translate(-50%, -60%);
        filter: drop-shadow(0 5px 14px rgba(0, 0, 0, 0.85));
        user-select: none;
        -webkit-user-select: none;
      }
      /* premove source/dest handled above */
      @media (max-width: 700px) {
        html,
        body {
          height: 100dvh;
          overflow: hidden;
        }
        header {
          padding: 3px 8px;
          min-height: 0;
        }
        .logo {
          font-size: 0.75rem;
        }
        .htip {
          display: none;
        }
        .hbtn:not(#mOnlineBtn) {
          display: none;
        }
        #mOnlineBtn {
          display: block;
        }
        .wrap {
          flex-direction: column;
          align-items: center;
        }
        .evbar {
          flex-direction: row;
          width: 100%;
          height: 18px;
          padding: 0 8px;
          gap: 6px;
          border-right: none;
          border-bottom: 1px solid var(--brd);
          flex-shrink: 0;
          justify-content: center;
          align-items: center;
          background: var(--sur);
        }
        .evtrack {
          flex: 1;
          width: auto;
          height: 7px;
          min-height: 0;
          border-radius: 4px;
          overflow: hidden;
          background: #111;
          position: relative;
        }
        .evw {
          position: absolute;
          right: 0;
          top: 0;
          bottom: 0;
          height: 100% !important;
          width: 50%;
          border-radius: 0 3px 3px 0;
          background: linear-gradient(to right, #ccc, #eee);
          transition: width 0.4s;
        }
        .evb {
          position: absolute;
          left: 0;
          top: 0;
          bottom: 0;
          height: 100% !important;
          width: 50%;
          border-radius: 3px 0 0 3px;
          background: linear-gradient(to left, #444, #1a1a1a);
          transition: width 0.4s;
        }
        .evmid {
          left: 50%;
          top: 0;
          bottom: 0;
          right: auto;
          width: 1px;
          height: auto;
        }
        .evlbl-w,
        .evlbl-b {
          display: none;
        }
        .evsc {
          font-size: 0.5rem;
          min-width: 22px;
          text-align: center;
          left: 13px;
        }
        .rpanel {
          display: none;
        }
        .center {
          flex: 1;
          min-height: 0;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 2px 0;
          gap: 1px;
          overflow: hidden;
          width: 100%;
        }
        :root {
          --lbl: 14px;
        }
        .board {
          --bsize: min(100vw, calc(100dvh - 138px));
          --sq: calc((var(--bsize) - var(--lbl) * 2 - 4px) / 8);
          border-width: 1px;
          box-shadow: none;
        }
        .pinfo {
          width: calc(var(--sq) * 8 + var(--lbl) * 2 + 4px);
          max-width: calc(100vw - 4px);
          padding: 1px 5px;
          flex-shrink: 0;
        }
        .pnm {
          font-size: 0.52rem;
        }
        .caps {
          font-size: 0.58rem;
          max-width: 100px;
        }
        .psc {
          font-size: 0.5rem;
        }
        .timer {
          font-size: 0.72rem;
          min-width: 44px;
        }
        .blbl {
          font-size: 0.52rem;
        }
        #mbar {
          display: flex;
          flex-shrink: 0;
        }
        .toast {
          bottom: auto;
          top: 50%;
          right: 50%;
          min-width: 160px;
          transform: translate(50%, -50%) translateY(14px);
        }
        .toast.on {
          transform: translate(50%, -50%) translateY(0);
        }
        .lbox {
          padding: 14px 12px;
          gap: 8px;
          width: min(400px, 95vw);
        }
        .lplayer {
          min-width: 70px;
          padding: 6px 8px;
        }
      }
      @media (max-width: 380px) {
        :root {
          --lbl: 12px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="logo">Control Chess <em>variant</em></div>
      <div class="hright">
        <span class="htip"
          >‚ùÑ freeze ¬∑ üö´ no same-adj ¬∑ ‚öî no same-capture ¬∑ ‚ö° pre-move</span
        >
        <button class="hbtn" id="mOnlineBtn" style="display: none">
          üåê Online
        </button>
        <button class="hbtn gold" id="onlineBtn">üåê Play Online</button>
      </div>
    </header>
    <div class="wrap">
      <div class="center">
        <div class="pinfo" id="pinfoTop">
          <div style="display: flex; align-items: center; gap: 5px">
            <span>‚ôü</span>
            <div>
              <div class="pnm" id="pnmTop">Bot (Black)</div>
              <div
                id="eloTop"
                style="
                  font-size: 0.6rem;
                  color: var(--gold);
                  font-family: Cinzel, serif;
                  display: none;
                "
              ></div>
              <div class="caps" id="capW"></div>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 8px">
            <div class="timer" id="timerTop">10:00</div>
            <div class="psc" id="scB"></div>
          </div>
        </div>
        <div
          id="drawOfferBanner"
          style="
            display: none;
            width: calc(var(--sq) * 8 + var(--lbl) * 2 + 4px);
            max-width: 100%;
            background: #1a3a1a;
            border: 1px solid #4caf50;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 4px;
            display: none;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-shrink: 0;
          "
        >
          <span style="color: #81c784; font-size: 0.85rem; font-weight: 600"
            >ü§ù <span id="drawOfferText">Opponent offers a draw</span></span
          >
          <div style="display: flex; gap: 6px">
            <button
              id="drawAcceptBtn"
              style="
                background: #4caf50;
                color: #fff;
                border: none;
                border-radius: 4px;
                padding: 4px 12px;
                cursor: pointer;
                font-weight: 700;
              "
            >
              ‚úì Accept
            </button>
            <button
              id="drawDeclineBtn"
              style="
                background: #c62828;
                color: #fff;
                border: none;
                border-radius: 4px;
                padding: 4px 12px;
                cursor: pointer;
                font-weight: 700;
              "
            >
              ‚úó Decline
            </button>
          </div>
        </div>
        <div style="display: flex; align-items: center; gap: 0; flex-shrink: 0">
          <div class="evbar" id="evbar">
            <div class="evtrack" id="evtrack">
              <div class="evb" id="evB" style="height: 50%"></div>
              <div class="evw" id="evW" style="height: 50%"></div>
              <div class="evmid"></div>
              <div class="evlbl-b" id="evLblB"></div>
              <div class="evlbl-w" id="evLblW"></div>
            </div>
            <div class="evsc" id="evSc">+0.0</div>
          </div>
          <div class="bwrap" id="bwrap">
            <div class="b-top" id="labTop"></div>
            <div class="b-mid">
              <div class="b-left" id="labLeft"></div>
              <div class="board" id="board"></div>
              <svg
                id="drawSvg"
                style="
                  position: absolute;
                  inset: 0;
                  width: 100%;
                  height: 100%;
                  pointer-events: none;
                  z-index: 10;
                  overflow: visible;
                "
              ></svg>
              <div class="b-right" id="labRight"></div>
            </div>
            <div class="b-bot" id="labBot"></div>
          </div>
        </div>
        <div class="pinfo" id="pinfoBot">
          <div style="display: flex; align-items: center; gap: 5px">
            <span>‚ôô</span>
            <div>
              <div class="pnm" id="pnmBot">You (White)</div>
              <div
                id="eloBot"
                style="
                  font-size: 0.6rem;
                  color: var(--gold);
                  font-family: Cinzel, serif;
                  display: none;
                "
              ></div>
              <div class="caps" id="capB"></div>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 8px">
            <div class="timer" id="timerBot">10:00</div>
            <div class="psc" id="scW"></div>
          </div>
        </div>
      </div>
      <div class="rpanel">
        <div class="card">
          <div class="chdr" id="hS">‚öî Status <i class="arr">‚ñº</i></div>
          <div class="cbody" id="bS">
            <div class="sbody" id="statusEl"></div>
            <div class="thk" id="thkEl">
              <div class="d"></div>
              <div class="d"></div>
              <div class="d"></div>
              <span>Thinking‚Ä¶</span>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="chdr" id="hR">‚òÖ Move Quality <i class="arr">‚ñº</i></div>
          <div class="cbody" id="bR">
            <div class="rbody" id="ratingEl">
              <span style="color: var(--dim); font-size: 0.7rem"
                >‚Äî make a move ‚Äî</span
              >
            </div>
          </div>
        </div>
        <div class="card">
          <div class="chdr" id="hM">‚ôü History <i class="arr">‚ñº</i></div>
          <div class="cbody" id="bM">
            <div class="mbody" id="movesEl"></div>
          </div>
        </div>
        <div class="card">
          <div class="chdr" id="hB">ü§ñ Bot Level <i class="arr">‚ñº</i></div>
          <div class="cbody" id="bB">
            <div class="dwrap">
              <button class="lb" data-l="1">Trivial</button>
              <button class="lb on" data-l="2">Easy</button>
              <button class="lb" data-l="3">Medium</button>
              <button class="lb" data-l="4">Hard</button>
              <button class="lb" data-l="5">Impossible</button>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="chdr" id="hElo">üèÜ ELO <i class="arr">‚ñº</i></div>
          <div class="cbody" id="bElo">
            <div style="padding: 8px 10px">
              <div
                style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  margin-bottom: 6px;
                "
              >
                <span style="font-size: 0.7rem; color: var(--dim)"
                  >Twoje ELO</span
                >
                <span
                  id="eloVal"
                  style="
                    font-family: Cinzel, serif;
                    font-size: 1.1rem;
                    color: var(--gold);
                    font-weight: 700;
                  "
                  >500</span
                >
              </div>
              <div
                id="eloChange"
                style="
                  font-size: 0.68rem;
                  color: var(--dim);
                  min-height: 14px;
                  margin-bottom: 4px;
                "
              ></div>
              <div
                id="eloHistory"
                style="
                  font-size: 0.62rem;
                  color: var(--dim);
                  max-height: 80px;
                  overflow-y: auto;
                "
              ></div>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="chdr cl" id="hRu">üìã Rules <i class="arr">‚ñº</i></div>
          <div class="cbody cl" id="bRu">
            <div class="rls">
              <div class="rl">
                <span class="ri">‚ùÑ</span
                ><span
                  ><b>Freeze:</b> After your move, enemy pieces attacked by a
                  higher-value piece of yours are frozen next turn. Kings &
                  pawns never freeze.
                  <b>A frozen piece loses its own freezing power</b>.</span
                >
              </div>
              <div class="rl">
                <span class="ri">üö´</span
                ><span
                  ><b>No same-adj:</b> Pieces (not pawns/kings) can't land
                  adjacent to same-type ally.</span
                >
              </div>
              <div class="rl">
                <span class="ri">¬Ω</span
                ><span
                  ><b>Draws:</b> Stalemate, agreement, 50-move rule, threefold
                  repetition, insufficient material.</span
                >
              </div>
              <div class="rl">
                <span class="ri">‚öî</span
                ><span
                  ><b>No same-capture:</b> Can't capture same type. Exception:
                  pawns can capture pawns.</span
                >
              </div>
              <div class="rl">
                <span class="ri">‚ö°</span
                ><span
                  ><b>Pre-move:</b> During opponent's turn, click your piece to
                  queue a move. It executes instantly when your turn
                  comes.</span
                >
              </div>
              <div class="rl">
                <span class="ri">‚úì</span
                ><span>Castling & promotion OK. No en passant.</span>
              </div>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="chdr" id="hV">üëÅ View Options <i class="arr">‚ñº</i></div>
          <div class="cbody" id="bV">
            <div
              class="dwrap"
              style="flex-direction: column; gap: 4px; padding: 4px 0"
            >
              <label class="ltoggle"
                ><input type="checkbox" id="togEval" checked /> üìä Eval
                bar</label
              >
              <label class="ltoggle"
                ><input type="checkbox" id="togRating" checked /> ‚òÖ Move
                ratings</label
              >
              <label class="ltoggle"
                ><input type="checkbox" id="togLocal" /> üë• Local 2-player (same
                screen)</label
              >
            </div>
          </div>
        </div>
        <div class="brow">
          <button class="btn bgd" id="newBtn">New Game</button>
          <button class="btn bsc" id="flipBtn">Flip</button>
        </div>
        <div class="brow">
          <button class="btn bsc" id="resignBtn">Resign</button>
          <button class="btn bsc" id="drawBtn">Offer Draw</button>
        </div>
      </div>
    </div>
    <div id="mbar">
      <div class="mr">
        <span class="mst" id="mSt">Your turn</span>
        <span class="mrt" id="mRt"></span>
        <span class="mev" id="mEv">0.0</span>
      </div>
      <div class="mr">
        <button class="mbtn mgold" id="mOnline2">üåê</button>
        <button class="mbtn" id="mLocal" title="Local 2-player">üë•</button>
        <div class="mthk" id="mThk">
          <div class="d"></div>
          <div class="d"></div>
          <div class="d"></div>
        </div>
        <div class="mpls" id="mBotLvls">
          <button class="mpl" data-l="1">Trivial</button>
          <button class="mpl on" data-l="2">Easy</button>
          <button class="mpl" data-l="3">Medium</button>
          <button class="mpl" data-l="4">Hard</button>
          <button class="mpl" data-l="5">Impossible</button>
        </div>
        <button class="mbtn" id="mFlip">‚áÑ</button>
        <button class="mbtn" id="mNew">New</button>
        <button class="mbtn" id="mRes">Resign</button>
        <button class="mbtn" id="mDrw">Draw?</button>
      </div>
    </div>
    <!-- PROMO -->
    <div class="modal" id="promoModal">
      <div class="mbox">
        <div class="mbt">Promote pawn</div>
        <div style="display: flex; gap: 10px" id="promoBox"></div>
      </div>
    </div>
    <!-- CONFIRM -->
    <div class="modal" id="confModal">
      <div class="mbox">
        <div class="mbt" id="cfTi"></div>
        <div class="mbs" id="cfSu"></div>
        <div class="mbbs">
          <button class="mbb y" id="cfYes">Yes</button
          ><button class="mbb n" id="cfNo">No</button>
        </div>
      </div>
    </div>
    <!-- TOAST -->
    <div class="toast" id="toast">
      <div class="tti" id="tTi"></div>
      <div class="tsu" id="tSu"></div>
      <div
        id="tEloResult"
        style="
          display: none;
          font-size: 0.72rem;
          color: var(--gold);
          font-family: Cinzel, serif;
          text-align: center;
          padding: 2px 0;
        "
      ></div>
      <div
        id="tEloBreakdown"
        style="
          display: none;
          font-size: 0.6rem;
          color: var(--dim);
          max-height: 90px;
          overflow-y: auto;
          border-top: 1px solid var(--brd);
          padding-top: 4px;
          margin-top: 2px;
        "
      ></div>
      <div class="tbtnrow">
        <button class="tbtn" id="tNew">New Game</button>
        <button class="tbtn sec" id="tRematch" style="display: none">
          ‚áÑ Rematch
        </button>
      </div>
    </div>
    <!-- LOBBY -->
    <div class="lobby" id="lobby">
      <div class="lbox">
        <div class="ltitle">üåê Play Online</div>
        <div class="lsec">
          <div class="llabel">Your Name</div>
          <input
            class="linput"
            id="lobbyName"
            placeholder="Player"
            maxlength="20"
          />
        </div>
        <div class="lsec" id="lOptsSec">
          <div class="llabel">Visibility options (host decides)</div>
          <div class="lopts" style="margin-top: 4px">
            <label class="ltoggle"
              ><input type="checkbox" id="optEval" checked /> üìä Eval bar</label
            >
            <label class="ltoggle"
              ><input type="checkbox" id="optRating" checked /> ‚òÖ Move
              ratings</label
            >
          </div>
        </div>
        <div class="lplayers">
          <div class="lplayer joined" id="lpHost">
            <div class="lpnm" id="lpHostNm">You</div>
            <div class="lpst">Host ‚ôî</div>
          </div>
          <div class="lvs">vs</div>
          <div class="lplayer" id="lpGuest">
            <div class="lpnm" id="lpGuestNm">Waiting‚Ä¶</div>
            <div class="lpst" id="lpGuestSt">No one yet</div>
            <button class="lkick" id="lKick" style="display: none">
              ‚úï Kick
            </button>
          </div>
        </div>
        <div class="lsec" id="lLinkSec" style="display: none">
          <div class="llabel" id="lLinkLabel">
            üîó Invite link ‚Äî click to copy & send to friend
          </div>
          <div class="llink" id="lobbyLink"></div>
          <div
            style="font-size: 0.6rem; color: var(--grn); margin-top: 2px"
            id="lCopyMsg"
          ></div>
        </div>
        <div class="lsec" id="lTimeSec" style="display: none">
          <div class="llabel" style="text-align: center">‚è± Time Control</div>
          <div class="tpicker" id="tPicker"></div>
        </div>
        <div class="lmsg" id="lMsg"></div>
        <div class="lbtnrow">
          <button class="btn bgd" id="lStart" style="display: none; flex: 1">
            ‚ñ∂ Start Game
          </button>
          <button class="btn bsc" id="lClose" style="flex: 1">‚úï Close</button>
        </div>
        <div class="lcstat" id="lCStat"></div>
      </div>
    </div>

    <!-- LOCAL TIME PICKER MODAL -->
    <div class="modal" id="localTimeModal">
      <div class="mbox" style="gap: 14px; min-width: 280px">
        <div class="mbt">‚è± Local Game Time Control</div>
        <div
          class="tpicker"
          id="localTPicker"
          style="justify-content: center; max-width: 320px"
        ></div>
        <div style="display: flex; gap: 8px; margin-top: 4px">
          <button class="mbb y" id="localTimeOk">‚ñ∂ Start</button>
          <button class="mbb n" id="localTimeNoTimer">No Timer</button>
          <button class="mbb n" id="localTimeCancel">Cancel</button>
        </div>
      </div>
    </div>

    <script>
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // CHESS ENGINE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const SYM = {
        wK: "‚ôî",
        wQ: "‚ôï",
        wR: "‚ôñ",
        wB: "‚ôó",
        wN: "‚ôò",
        wP: "‚ôô",
        bK: "‚ôö",
        bQ: "‚ôõ",
        bR: "‚ôú",
        bB: "‚ôù",
        bN: "‚ôû",
        bP: "‚ôü",
      };
      const VAL = { K: 20000, Q: 900, R: 500, B: 330, N: 320, P: 100 };
      const PST = {
        P: [
          0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20,
          30, 30, 20, 10, 10, 5, 5, 10, 25, 25, 10, 5, 5, 0, 0, 0, 20, 20, 0, 0,
          0, 5, -5, -10, 0, 0, -10, -5, 5, 5, 10, 10, -20, -20, 10, 10, 5, 0, 0,
          0, 0, 0, 0, 0, 0,
        ],
        N: [
          -50, -40, -30, -30, -30, -30, -40, -50, -40, -20, 0, 0, 0, 0, -20,
          -40, -30, 0, 10, 15, 15, 10, 0, -30, -30, 5, 15, 20, 20, 15, 5, -30,
          -30, 0, 15, 20, 20, 15, 0, -30, -30, 5, 10, 15, 15, 10, 5, -30, -40,
          -20, 0, 5, 5, 0, -20, -40, -50, -40, -30, -30, -30, -30, -40, -50,
        ],
        B: [
          -20, -10, -10, -10, -10, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10,
          -10, 0, 5, 10, 10, 5, 0, -10, -10, 5, 5, 10, 10, 5, 5, -10, -10, 0,
          10, 10, 10, 10, 0, -10, -10, 10, 10, 10, 10, 10, 10, -10, -10, 5, 0,
          0, 0, 0, 5, -10, -20, -10, -10, -10, -10, -10, -10, -20,
        ],
        R: [
          0, 0, 0, 0, 0, 0, 0, 0, 5, 10, 10, 10, 10, 10, 10, 5, -5, 0, 0, 0, 0,
          0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0,
          0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, 0, 0, 0, 5, 5, 0, 0, 0,
        ],
        Q: [
          -20, -10, -10, -5, -5, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10,
          0, 5, 5, 5, 5, 0, -10, -5, 0, 5, 5, 5, 5, 0, -5, 0, 0, 5, 5, 5, 5, 0,
          -5, -10, 5, 5, 5, 5, 5, 0, -10, -10, 0, 5, 0, 0, 0, 0, -10, -20, -10,
          -10, -5, -5, -10, -10, -20,
        ],
        K: [
          -30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40,
          -40, -30, -30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50,
          -50, -40, -40, -30, -20, -30, -30, -40, -40, -30, -30, -20, -10, -20,
          -20, -20, -20, -20, -20, -10, 20, 20, 0, 0, 0, 0, 20, 20, 20, 30, 10,
          0, 0, 10, 30, 20,
        ],
      };
      const FILES = "abcdefgh",
        RANKS = "87654321";

      // Enhanced move ratings ‚Äî 14 categories
      const RTNG = [
        { l: "Brilliant!!", s: "!!", c: "br", mn: 300 },
        { l: "Genius!!!", s: "!!!", c: "br", mn: 500 }, // ultra-brilliant
        { l: "Great!", s: "!", c: "gr", mn: 100 },
        { l: "Best", s: "‚òÖ", c: "be", mn: 40 },
        { l: "Excellent", s: "‚úì", c: "ex", mn: 15 },
        { l: "Good", s: "¬∑", c: "go", mn: 3 },
        { l: "Book", s: "=", c: "ok", mn: -3 }, // equal/book move
        { l: "Okay", s: "‚óã", c: "ok", mn: -20 },
        { l: "Inaccuracy", s: "?!", c: "in", mn: -50 },
        { l: "Mistake", s: "?", c: "mi", mn: -120 },
        { l: "Blunder", s: "??", c: "bl", mn: -250 },
        { l: "Catastrophe", s: "???", c: "ct", mn: -500 },
        { l: "Losing", s: "‚úó", c: "ct", mn: -9999 },
      ];
      // Sort by mn descending so first match wins
      RTNG.sort((a, b) => b.mn - a.mn);

      const cp = (b) => b.map((r) => [...r]);
      const opp = (c) => (c === "w" ? "b" : "w");

      function adj8(r, c) {
        const a = [];
        for (let dr = -1; dr <= 1; dr++)
          for (let dc = -1; dc <= 1; dc++)
            if (dr || dc) {
              const nr = r + dr,
                nc = c + dc;
              if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) a.push([nr, nc]);
            }
        return a;
      }
      function adjOk(brd, tr, tc, type) {
        if (type === "P" || type === "K") return true;
        for (const [r, c] of adj8(tr, tc)) {
          const n = brd[r][c];
          if (n && n[1] === type) return false;
        }
        return true;
      }
      function atkSet(brd, col) {
        const s = new Set();
        for (let r = 0; r < 8; r++)
          for (let c = 0; c < 8; c++) {
            const p = brd[r][c];
            if (!p || p[0] !== col) continue;
            const t = p[1];
            if (t === "P") {
              const d = col === "w" ? -1 : 1;
              for (const dc of [-1, 1]) {
                const nr = r + d,
                  nc = c + dc;
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) s.add(nr * 8 + nc);
              }
            } else if (t === "N") {
              for (const [dr, dc] of [
                [2, 1],
                [2, -1],
                [-2, 1],
                [-2, -1],
                [1, 2],
                [1, -2],
                [-1, 2],
                [-1, -2],
              ]) {
                const nr = r + dr,
                  nc = c + dc;
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) s.add(nr * 8 + nc);
              }
            } else if (t === "K") {
              for (const [nr, nc] of adj8(r, c)) s.add(nr * 8 + nc);
            } else {
              const D =
                t === "B"
                  ? [
                      [1, 1],
                      [1, -1],
                      [-1, 1],
                      [-1, -1],
                    ]
                  : t === "R"
                    ? [
                        [1, 0],
                        [-1, 0],
                        [0, 1],
                        [0, -1],
                      ]
                    : [
                        [1, 1],
                        [1, -1],
                        [-1, 1],
                        [-1, -1],
                        [1, 0],
                        [-1, 0],
                        [0, 1],
                        [0, -1],
                      ];
              for (const [dr, dc] of D) {
                let nr = r + dr,
                  nc = c + dc;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                  s.add(nr * 8 + nc);
                  if (brd[nr][nc]) break;
                  nr += dr;
                  nc += dc;
                }
              }
            }
          }
        return s;
      }
      function inCheck(brd, col) {
        const a = atkSet(brd, opp(col));
        for (let r = 0; r < 8; r++)
          for (let c = 0; c < 8; c++)
            if (brd[r][c] === col + "K" && a.has(r * 8 + c)) return true;
        return false;
      }
      function reach(brd, ar, ac, tr, tc, type) {
        if (type === "P") {
          const d = brd[ar][ac][0] === "w" ? -1 : 1;
          return tr === ar + d && Math.abs(tc - ac) === 1;
        }
        if (type === "N") {
          const dr = Math.abs(tr - ar),
            dc = Math.abs(tc - ac);
          return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
        }
        if (type === "K")
          return (
            Math.abs(tr - ar) <= 1 &&
            Math.abs(tc - ac) <= 1 &&
            (tr !== ar || tc !== ac)
          );
        if (type === "B") {
          if (Math.abs(tr - ar) !== Math.abs(tc - ac)) return false;
          const dr = Math.sign(tr - ar),
            dc = Math.sign(tc - ac);
          let r = ar + dr,
            c = ac + dc;
          while (r !== tr || c !== tc) {
            if (brd[r][c]) return false;
            r += dr;
            c += dc;
          }
          return true;
        }
        if (type === "R") {
          if (tr !== ar && tc !== ac) return false;
          const dr = Math.sign(tr - ar),
            dc = Math.sign(tc - ac);
          let r = ar + dr,
            c = ac + dc;
          while (r !== tr || c !== tc) {
            if (brd[r][c]) return false;
            r += dr;
            c += dc;
          }
          return true;
        }
        if (type === "Q")
          return (
            reach(brd, ar, ac, tr, tc, "B") || reach(brd, ar, ac, tr, tc, "R")
          );
        return false;
      }
      function frozenBy(brd, atkCol, prevFrzAtk) {
        const def = opp(atkCol),
          res = [];
        for (let tr = 0; tr < 8; tr++)
          for (let tc = 0; tc < 8; tc++) {
            const tgt = brd[tr][tc];
            if (!tgt || tgt[0] !== def || tgt[1] === "K" || tgt[1] === "P")
              continue;
            const tgtVal = VAL[tgt[1]] || 0;
            let best = 0;
            for (let ar = 0; ar < 8; ar++)
              for (let ac = 0; ac < 8; ac++) {
                const a = brd[ar][ac];
                if (
                  !a ||
                  a[0] !== atkCol ||
                  a[1] === tgt[1] ||
                  a[1] === "P" ||
                  a[1] === "K"
                )
                  continue;
                if (prevFrzAtk && prevFrzAtk.has(ar * 8 + ac)) continue;
                const av = VAL[a[1]] || 0;
                if (
                  av > tgtVal &&
                  reach(brd, ar, ac, tr, tc, a[1]) &&
                  av > best
                )
                  best = av;
              }
            if (best > 0) res.push(tr * 8 + tc);
          }
        return res;
      }
      function calcFrz(brd, prevFrz) {
        const prevFrzW = prevFrz ? new Set(prevFrz.byW) : null;
        const prevFrzB = prevFrz ? new Set(prevFrz.byB) : null;
        const byW = frozenBy(brd, "w", prevFrzW);
        const byB = frozenBy(brd, "b", prevFrzB);
        return { byW, byB, all: [...new Set([...byW, ...byB])] };
      }
      function movesFrom(brd, r, c, castl, frozenArr) {
        const p = brd[r][c];
        if (!p) return [];
        const col = p[0],
          type = p[1],
          en = opp(col);
        if (type !== "P" && type !== "K" && frozenArr.includes(r * 8 + c))
          return [];
        const mvs = [];
        function push(tr, tc, flag) {
          if (tr < 0 || tr >= 8 || tc < 0 || tc >= 8) return;
          const tgt = brd[tr][tc];
          if (tgt && tgt[0] === col) return;
          if (tgt && tgt[1] === type && type !== "P") return;
          const nb = cp(brd);
          nb[tr][tc] = p;
          nb[r][c] = null;
          if (flag === "cs") {
            nb[tr][5] = col + "R";
            nb[tr][7] = null;
          }
          if (flag === "cl") {
            nb[tr][3] = col + "R";
            nb[tr][0] = null;
          }
          if (!adjOk(nb, tr, tc, type)) return;
          if (inCheck(nb, col)) return;
          mvs.push({ fr: r, fc: c, tr, tc, flag: flag || null });
        }
        if (type === "P") {
          const d = col === "w" ? -1 : 1,
            sR = col === "w" ? 6 : 1;
          if (r + d >= 0 && r + d < 8 && !brd[r + d][c]) {
            push(r + d, c, null);
            if (r === sR && !brd[r + 2 * d][c]) push(r + 2 * d, c, null);
          }
          for (const dc of [-1, 1]) {
            const nr = r + d,
              nc = c + dc;
            if (
              nr >= 0 &&
              nr < 8 &&
              nc >= 0 &&
              nc < 8 &&
              brd[nr][nc] &&
              brd[nr][nc][0] === en
            )
              push(nr, nc, null);
          }
          return mvs;
        }
        if (type === "N") {
          for (const [dr, dc] of [
            [2, 1],
            [2, -1],
            [-2, 1],
            [-2, -1],
            [1, 2],
            [1, -2],
            [-1, 2],
            [-1, -2],
          ])
            push(r + dr, c + dc, null);
          return mvs;
        }
        if (type === "K") {
          for (const [nr, nc] of adj8(r, c)) push(nr, nc, null);
          const rk = col === "w" ? 7 : 0;
          if (r === rk && c === 4 && !inCheck(brd, col)) {
            const ea = atkSet(brd, en);
            if (
              castl[col + "K"] &&
              !brd[rk][5] &&
              !brd[rk][6] &&
              !ea.has(rk * 8 + 5) &&
              !ea.has(rk * 8 + 6) &&
              !frozenArr.includes(rk * 8 + 7)
            ) {
              const nb = cp(brd);
              nb[rk][6] = p;
              nb[rk][5] = col + "R";
              nb[rk][7] = null;
              nb[rk][4] = null;
              if (!inCheck(nb, col))
                mvs.push({ fr: r, fc: 4, tr: rk, tc: 6, flag: "cs" });
            }
            if (
              castl[col + "Q"] &&
              !brd[rk][3] &&
              !brd[rk][2] &&
              !brd[rk][1] &&
              !ea.has(rk * 8 + 3) &&
              !ea.has(rk * 8 + 2) &&
              !frozenArr.includes(rk * 8 + 0)
            ) {
              const nb = cp(brd);
              nb[rk][2] = p;
              nb[rk][3] = col + "R";
              nb[rk][0] = null;
              nb[rk][4] = null;
              if (!inCheck(nb, col))
                mvs.push({ fr: r, fc: 4, tr: rk, tc: 2, flag: "cl" });
            }
          }
          return mvs;
        }
        const D =
          type === "B"
            ? [
                [1, 1],
                [1, -1],
                [-1, 1],
                [-1, -1],
              ]
            : type === "R"
              ? [
                  [1, 0],
                  [-1, 0],
                  [0, 1],
                  [0, -1],
                ]
              : [
                  [1, 1],
                  [1, -1],
                  [-1, 1],
                  [-1, -1],
                  [1, 0],
                  [-1, 0],
                  [0, 1],
                  [0, -1],
                ];
        for (const [dr, dc] of D) {
          let nr = r + dr,
            nc = c + dc;
          while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            const tgt = brd[nr][nc];
            if (tgt) {
              if (tgt[0] === en && tgt[1] !== type) push(nr, nc, null);
              break;
            }
            push(nr, nc, null);
            nr += dr;
            nc += dc;
          }
        }
        return mvs;
      }
      function allMoves(brd, col, castl, frz) {
        const ms = [];
        for (let r = 0; r < 8; r++)
          for (let c = 0; c < 8; c++)
            if (brd[r][c] && brd[r][c][0] === col)
              ms.push(...movesFrom(brd, r, c, castl, frz));
        return ms;
      }
      function applyMv(brd, mv, col) {
        const { fr, fc, tr, tc, flag } = mv,
          p = brd[fr][fc];
        brd[tr][tc] = p;
        brd[fr][fc] = null;
        if (flag === "cs") {
          brd[tr][5] = col + "R";
          brd[tr][7] = null;
        }
        if (flag === "cl") {
          brd[tr][3] = col + "R";
          brd[tr][0] = null;
        }
        if (p === col + "P" && (tr === 0 || tr === 7)) brd[tr][tc] = col + "Q";
      }
      function evalBoard(brd) {
        let s = 0;
        // Material + PST
        for (let r = 0; r < 8; r++)
          for (let c = 0; c < 8; c++) {
            const p = brd[r][c];
            if (!p) continue;
            const col = p[0],
              t = p[1],
              idx = col === "w" ? r * 8 + c : (7 - r) * 8 + c;
            s += (col === "w" ? 1 : -1) * (VAL[t] + ((PST[t] || [])[idx] || 0));
          }
        // Control Chess: freeze penalty ‚Äî frozen pieces lose their value contribution
        const frz = calcFrz(brd, null);
        for (const k of frz.byW) {
          const r = Math.floor(k / 8),
            c2 = k % 8;
          const p = brd[r][c2];
          if (p && p[0] === "w") s -= VAL[p[1]] * 0.35;
        }
        for (const k of frz.byB) {
          const r = Math.floor(k / 8),
            c2 = k % 8;
          const p = brd[r][c2];
          if (p && p[0] === "b") s += VAL[p[1]] * 0.35;
        }
        return s;
      }

      // ‚îÄ‚îÄ‚îÄ Deep eval: quiescence search + deeper alpha-beta ‚îÄ‚îÄ‚îÄ
      function quiesce(brd, alpha, beta, col, depth) {
        const stand = col === "w" ? evalBoard(brd) : -evalBoard(brd);
        if (depth <= 0) return stand;
        if (stand >= beta) return beta;
        if (stand > alpha) alpha = stand;
        // Only captures
        const ms = [];
        for (let r = 0; r < 8; r++)
          for (let c = 0; c < 8; c++) {
            const p = brd[r][c];
            if (!p || p[0] !== col) continue;
            for (let tr = 0; tr < 8; tr++)
              for (let tc = 0; tc < 8; tc++) {
                if (!brd[tr][tc] || brd[tr][tc][0] === col) continue;
                const mv = { fr: r, fc: c, tr, tc, flag: null };
                // Quick legality via movesFrom subset check - use reach
                if (p[1] === "P") {
                  const d = p[0] === "w" ? -1 : 1;
                  if (tr !== r + d || Math.abs(tc - c) !== 1) continue;
                } else if (!reach(brd, r, c, tr, tc, p[1])) continue;
                if (brd[tr][tc][1] === p[1] && p[1] !== "P") continue;
                ms.push(mv);
              }
          }
        ms.sort(
          (a, b) =>
            (VAL[brd[b.tr][b.tc][1]] || 0) - (VAL[brd[a.tr][a.tc][1]] || 0),
        );
        for (const mv of ms) {
          const nb = cp(brd);
          applyMv(nb, mv, col);
          const sc = -quiesce(nb, -beta, -alpha, opp(col), depth - 1);
          if (sc >= beta) return beta;
          if (sc > alpha) alpha = sc;
        }
        return alpha;
      }

      function abDeep(brd, depth, alpha, beta, col, castl, frz, ply, deadline) {
        if (deadline && Date.now() > deadline)
          return evalBoard(brd) * (col === "w" ? 1 : -1);
        if (depth <= 0) return quiesce(brd, alpha, beta, col, 3);
        const ms = allMoves(brd, col, castl, frz);
        if (!ms.length) return inCheck(brd, col) ? -19000 + ply : 0;
        ms.sort(
          (a, b) =>
            (brd[b.tr][b.tc] ? VAL[brd[b.tr][b.tc][1]] || 0 : 0) -
            (brd[a.tr][a.tc] ? VAL[brd[a.tr][a.tc][1]] || 0 : 0),
        );
        let best = -Infinity;
        for (const mv of ms) {
          const nb = cp(brd),
            nc = { ...castl },
            p = brd[mv.fr][mv.fc];
          if (p === "wK") {
            nc.wK = false;
            nc.wQ = false;
          }
          if (p === "bK") {
            nc.bK = false;
            nc.bQ = false;
          }
          applyMv(nb, mv, col);
          const nf = calcFrz(nb);
          const nfrz = opp(col) === "w" ? nf.byB : nf.byW;
          const sc = -abDeep(
            nb,
            depth - 1,
            -beta,
            -alpha,
            opp(col),
            nc,
            nfrz,
            ply + 1,
            deadline,
          );
          if (sc > best) best = sc;
          if (sc > alpha) alpha = sc;
          if (alpha >= beta) break;
        }
        return best;
      }

      // Deep eval for move rating ‚Äî returns best possible score for side to move
      function deepEvalForSide(brd, col, castl, frz, depth) {
        const ms = allMoves(brd, col, castl, frz);
        if (!ms.length) return inCheck(brd, col) ? -19000 : 0;
        const deadline = Date.now() + 800; // 800ms budget
        let best = -Infinity;
        for (const mv of ms) {
          const nb = cp(brd),
            nc = { ...castl },
            p = brd[mv.fr][mv.fc];
          if (p === "wK") {
            nc.wK = false;
            nc.wQ = false;
          }
          if (p === "bK") {
            nc.bK = false;
            nc.bQ = false;
          }
          applyMv(nb, mv, col);
          const nf = calcFrz(nb);
          const nfrz = opp(col) === "w" ? nf.byB : nf.byW;
          const sc = -abDeep(
            nb,
            depth - 1,
            -Infinity,
            Infinity,
            opp(col),
            nc,
            nfrz,
            1,
            deadline,
          );
          if (sc > best) best = sc;
          if (Date.now() > deadline) break;
        }
        return best;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // GAME STATE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let G = {},
        botLevel = 2,
        flipped = false;
      let promoOk = null;
      let animH = [],
        animC = [],
        animOn = false;
      const DR = {
        on: false,
        ghost: null,
        fr: -1,
        fc: -1,
        poss: [],
        sx: 0,
        sy: 0,
        moved: false,
      };
      let tTimer = null,
        tXY = null,
        tMoved = false;
      let mDown = null,
        mXY = null;

      // Pre-move state
      let PREMOVE = { active: false, fr: -1, fc: -1, tr: -1, tc: -1 };

      // Online state
      let NET = {
        mode: "bot",
        peer: null,
        conn: null,
        myCol: "w",
        myName: "Player",
        oppName: "Bot",
        showEval: true,
        showRating: true,
        timeCtrl: null,
        timers: { w: 0, b: 0 },
        timerInterval: null,
        lastTimestamp: null,
        gameStarted: false,
        rematchTime: null,
      };

      const TIME_CTRLS = [
        { l: "1+0", base: 60000, inc: 0 },
        { l: "1+1", base: 60000, inc: 1000 },
        { l: "2+1", base: 120000, inc: 1000 },
        { l: "3+0", base: 180000, inc: 0 },
        { l: "3+2", base: 180000, inc: 2000 },
        { l: "5+0", base: 300000, inc: 0 },
        { l: "5+3", base: 300000, inc: 3000 },
        { l: "10+0", base: 600000, inc: 0 },
        { l: "10+5", base: 600000, inc: 5000 },
        { l: "15+10", base: 900000, inc: 10000 },
        { l: "30+0", base: 1800000, inc: 0 },
        { l: "60+0", base: 3600000, inc: 0 },
      ];
      let selectedTC = null,
        localSelectedTC = null;

      function formatTime(ms, showMs) {
        if (ms < 0) ms = 0;
        if (showMs) {
          // Show seconds.tenths
          const s = Math.floor(ms / 1000),
            tenth = Math.floor((ms % 1000) / 100);
          return s + "." + tenth;
        }
        const s = Math.ceil(ms / 1000);
        const m = Math.floor(s / 60),
          ss = s % 60;
        return m + ":" + (ss < 10 ? "0" : "") + ss;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // NEW GAME
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function newGame(tcOverride) {
        stopAnim();
        eloGameStart();
        PMQUEUE = [];
        PMSEL = null;
        PREMOVE = { active: false, fr: -1, fc: -1, tr: -1, tc: -1, poss: [] };
        const bk = ["R", "N", "B", "Q", "K", "B", "N", "R"];
        const brd = Array.from({ length: 8 }, () => Array(8).fill(null));
        for (let c = 0; c < 8; c++) {
          brd[0][c] = "b" + bk[c];
          brd[1][c] = "bP";
          brd[6][c] = "wP";
          brd[7][c] = "w" + bk[c];
        }
        G = {
          brd,
          turn: "w",
          sel: null,
          poss: [],
          hist: [],
          capW: [],
          capB: [],
          castl: { wK: true, wQ: true, bK: true, bQ: true },
          frz: calcFrz(brd, null),
          prevFrz: null,
          over: false,
          lastMv: null,
          prevEval: 0,
          halfMove: 0,
          posHist: [],
          bestEvalCache: null, // cache best move eval for rating
        };
        document.getElementById("toast").classList.remove("on");
        document.getElementById("movesEl").innerHTML = "";
        document.getElementById("ratingEl").innerHTML =
          '<span style="color:var(--dim);font-size:.7rem">‚Äî make a move ‚Äî</span>';
        document.getElementById("mRt").innerHTML = "";
        stopTimers();
        const tc = tcOverride || NET.timeCtrl;
        if (tc) {
          NET.timers = { w: tc.base, b: tc.base };
          showTimers(true);
          updateTimerDisplay();
          if (NET.mode === "bot") startTurnTimer("w");
        } else {
          showTimers(false);
        }
        setEval(0);
        const showEv = NET.showEval;
        document.getElementById("evbar").style.display = showEv ? "" : "none";
        const rCard = document.getElementById("bR");
        if (rCard && rCard.parentElement)
          rCard.parentElement.style.display = NET.showRating ? "" : "none";
        if (NET.mode === "local") flipped = false;
        render();
        updStatus();
        updCaps();
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // TIMERS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function showTimers(on) {
        const tt = document.getElementById("timerTop"),
          tb = document.getElementById("timerBot");
        if (tt) tt.style.display = on ? "block" : "none";
        if (tb) tb.style.display = on ? "block" : "none";
      }
      function stopTimers() {
        clearInterval(NET.timerInterval);
        NET.timerInterval = null;
        NET.lastTimestamp = null;
      }
      function startTurnTimer(col) {
        stopTimers();
        if (!NET.timeCtrl) return;
        NET.lastTimestamp = Date.now();
        NET.timerInterval = setInterval(() => tickTimer(col), 50); // 50ms precision
      }
      function tickTimer(col) {
        const now = Date.now(),
          dt = now - NET.lastTimestamp;
        NET.lastTimestamp = now;
        NET.timers[col] = Math.max(0, NET.timers[col] - dt);
        updateTimerDisplay();
        // Warning ticks at low time ‚Äî online: only for MY timer
        const t = NET.timers[col];
        if (t <= 10000 && t > 0) {
          const prev = t + dt;
          if (Math.floor(prev / 1000) > Math.floor(t / 1000)) {
            const isMyTimer =
              NET.mode === "bot" || NET.mode === "local"
                ? true
                : col === NET.myCol;
            if (isMyTimer) playLowTimeTick();
          }
        }
        if (t <= 0) {
          stopTimers();
          endGame("timeout", opp(col));
        }
      }
      function updateTimerDisplay() {
        // Determine which colour is shown at bottom (my side)
        const botCol =
          NET.mode === "bot"
            ? "w"
            : NET.mode === "local"
              ? flipped
                ? "b"
                : "w"
              : NET.myCol || "w";
        const topCol = opp(botCol);
        const tb = document.getElementById("timerBot"),
          tt = document.getElementById("timerTop");
        const btMs = (NET.timers && NET.timers[botCol]) || 0;
        const topMs = (NET.timers && NET.timers[topCol]) || 0;
        const btLow = btMs < 10000 && btMs > 0,
          topLow = topMs < 10000 && topMs > 0;
        if (tb) {
          tb.textContent = formatTime(btMs, btLow);
          tb.classList.toggle("active", G.turn === botCol && !G.over);
          tb.classList.toggle("low", btLow);
          tb.classList.toggle("critical", btLow);
        }
        if (tt) {
          tt.textContent = formatTime(topMs, topLow);
          tt.classList.toggle("active", G.turn === topCol && !G.over);
          tt.classList.toggle("low", topLow);
          tt.classList.toggle("critical", topLow);
        }
        if (document.getElementById("mSt")) updMobile();
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // PLAY MOVE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      async function playMove(mv, isBot, fromNet) {
        const { fr, fc, tr, tc, flag } = mv;
        const piece = G.brd[fr][fc],
          cap = G.brd[tr][tc];

        // Deep eval BEFORE move for rating comparison
        let preEval = G.prevEval;
        // Also compute what the best move would have scored (async, non-blocking for bot)
        let bestEval = G.bestEvalCache;

        const note = buildNote(G.brd, mv, G.turn);
        if (NET.timeCtrl) {
          stopTimers();
          if (NET.timeCtrl.inc)
            NET.timers[G.turn] = Math.min(
              NET.timers[G.turn] + NET.timeCtrl.inc,
              NET.timeCtrl.base * 2,
            );
        }
        if (piece === "wK") {
          G.castl.wK = false;
          G.castl.wQ = false;
        }
        if (piece === "bK") {
          G.castl.bK = false;
          G.castl.bQ = false;
        }
        if (fr === 7 && fc === 7) G.castl.wK = false;
        if (fr === 7 && fc === 0) G.castl.wQ = false;
        if (fr === 0 && fc === 7) G.castl.bK = false;
        if (fr === 0 && fc === 0) G.castl.bQ = false;
        G.brd[tr][tc] = piece;
        G.brd[fr][fc] = null;
        if (flag === "cs") {
          G.brd[tr][5] = G.turn + "R";
          G.brd[tr][7] = null;
        }
        if (flag === "cl") {
          G.brd[tr][3] = G.turn + "R";
          G.brd[tr][0] = null;
        }
        if (cap) (G.turn === "w" ? G.capW : G.capB).push(cap);
        if (piece === "wP" && tr === 0) {
          let q;
          if (fromNet)
            q = mv.promo || "wQ"; // use promo from network packet
          else if (isBot) q = "wQ";
          else q = await doPromo("w");
          G.brd[tr][tc] = q;
          mv.promo = q; // store in mv so netSend includes it
        }
        if (piece === "bP" && tr === 7) {
          let q;
          if (fromNet) q = mv.promo || "bQ";
          else if (isBot) q = "bQ";
          else q = await doPromo("b");
          G.brd[tr][tc] = q;
          mv.promo = q;
        }
        G.lastMv = { fr, fc, tr, tc };
        G.prevFrz = G.frz;
        G.frz = calcFrz(G.brd, G.prevFrz);
        const newEv = evalBoard(G.brd);
        G.prevEval = newEv;

        // ‚îÄ‚îÄ Move rating ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const movingCol = G.turn;
        const oppCol = opp(movingCol);

        // Helper: negamax eval from col's perspective, depth-limited, hard deadline
        function negaMax(brd, col, castl, frz, depth, alpha, beta, dl) {
          if (Date.now() > dl) return evalBoard(brd) * (col === "w" ? 1 : -1);
          if (depth <= 0) return evalBoard(brd) * (col === "w" ? 1 : -1);
          const ms = allMoves(brd, col, castl, frz);
          if (!ms.length) return inCheck(brd, col) ? -18000 + depth : 0;
          let best = -Infinity;
          for (const m of ms) {
            if (Date.now() > dl) break;
            const nb = cp(brd),
              nc = { ...castl },
              pp = brd[m.fr][m.fc];
            if (pp === "wK") {
              nc.wK = false;
              nc.wQ = false;
            }
            if (pp === "bK") {
              nc.bK = false;
              nc.bQ = false;
            }
            applyMv(nb, m, col);
            const nf = calcFrz(nb),
              nfrz = opp(col) === "w" ? nf.byB : nf.byW;
            const sc = -negaMax(
              nb,
              opp(col),
              nc,
              nfrz,
              depth - 1,
              -beta,
              -alpha,
              dl,
            );
            if (sc > best) best = sc;
            if (sc > alpha) alpha = sc;
            if (alpha >= beta) break;
          }
          return best;
        }

        const nextFrzNow = oppCol === "w" ? G.frz.byB : G.frz.byW;
        const oppMoves = allMoves(G.brd, oppCol, G.castl, nextFrzNow);
        const isCheckmate = oppMoves.length === 0 && inCheck(G.brd, oppCol);

        let ri;
        if (isCheckmate) {
          ri = 0; // Mat ‚Üí zawsze najlepsza ocena
        } else {
          // scoreActual: jak dobra jest pozycja dla movingCol po TYM ruchu
          // = negamax na aktualnej planszy z perspektywy oppCol, zanegowany
          const dl1 = Date.now() + 200;
          const scoreActual = -negaMax(
            G.brd,
            oppCol,
            G.castl,
            nextFrzNow,
            2,
            -Infinity,
            Infinity,
            dl1,
          );

          // scoreBest: jak dobra by≈Çaby pozycja gdyby movingCol zagra≈Ç NAJLEPSZY ruch
          // Mamy to w bestEvalCache z poprzedniego ruchu (obliczone synchronicznie poni≈ºej)
          // Je≈õli null (pierwszy ruch) ‚Üí eval materialny przed ruchem
          let scoreBest;
          if (bestEval !== null && bestEval !== undefined) {
            // bestEval jest w jednostkach white-positive; konwertuj na movingCol-positive
            scoreBest = bestEval * (movingCol === "w" ? 1 : -1);
          } else {
            // Pierwszy ruch: oblicz synchronicznie best mo≈ºliwy wynik
            const myFrzNow = movingCol === "w" ? G.frz.byB : G.frz.byW; // stan PRZED ruchem (ju≈º zastƒÖpiony)
            // Brak poprzednich danych ‚Äî u≈ºyj prostego materia≈Çu
            scoreBest = evalBoard(G.brd) * (movingCol === "w" ? 1 : -1);
          }

          const delta = scoreActual - scoreBest; // > 0: lepiej ni≈º best ‚Üí podejrzane; < 0: gorzej
          // Normalize: je≈õli gracz zagra≈Ç dok≈Çadnie najlepszy ruch, delta ‚âà 0
          ri = RTNG.length - 1;
          for (let i = 0; i < RTNG.length; i++)
            if (delta >= RTNG[i].mn) {
              ri = i;
              break;
            }
        }

        // Eval bar: shallow najpierw
        if (NET.showEval && !fromNet) setEval(evalBoard(G.brd));

        // Oblicz SYNCHRONICZNIE bestEvalCache dla NASTƒòPNEGO ruchu (dla oceny nastƒôpnego gracza)
        // Robimy to synchronicznie ≈ºeby by≈Ço dostƒôpne gdy gracz zagra ruch
        // Max 300ms ≈ºeby nie lagowaƒá
        {
          const _col = oppCol,
            _frz = nextFrzNow,
            _castl = { ...G.castl },
            _brd = G.brd;
          const ms2 = allMoves(_brd, _col, _castl, _frz);
          if (ms2.length) {
            const dl2 = Date.now() + 300;
            let best2 = -Infinity;
            for (const m of ms2) {
              if (Date.now() > dl2) break;
              const nb = cp(_brd),
                nc = { ..._castl },
                pp = _brd[m.fr][m.fc];
              if (pp === "wK") {
                nc.wK = false;
                nc.wQ = false;
              }
              if (pp === "bK") {
                nc.bK = false;
                nc.bQ = false;
              }
              applyMv(nb, m, _col);
              const nf = calcFrz(nb),
                nfrz = opp(_col) === "w" ? nf.byB : nf.byW;
              const sc = -negaMax(
                nb,
                opp(_col),
                nc,
                nfrz,
                1,
                -Infinity,
                Infinity,
                dl2,
              );
              if (sc > best2) best2 = sc;
            }
            // Zapisz w white-positive
            G.bestEvalCache = _col === "w" ? best2 : -best2;
            // Refined eval bar async
            setTimeout(() => {
              if (G.over) return;
              const dl3 = Date.now() + 500;
              let best3 = -Infinity;
              for (const m of ms2) {
                if (Date.now() > dl3) break;
                const nb = cp(_brd),
                  nc = { ..._castl },
                  pp = _brd[m.fr][m.fc];
                if (pp === "wK") {
                  nc.wK = false;
                  nc.wQ = false;
                }
                if (pp === "bK") {
                  nc.bK = false;
                  nc.bQ = false;
                }
                applyMv(nb, m, _col);
                const nf = calcFrz(nb),
                  nfrz = opp(_col) === "w" ? nf.byB : nf.byW;
                const sc = -negaMax(
                  nb,
                  opp(_col),
                  nc,
                  nfrz,
                  3,
                  -Infinity,
                  Infinity,
                  dl3,
                );
                if (sc > best3) best3 = sc;
              }
              G.bestEvalCache = _col === "w" ? best3 : -best3;
              if (NET.showEval && !fromNet) {
                setEval(G.bestEvalCache);
                if (NET.conn)
                  netSend({ type: "eval_sync", ev: G.bestEvalCache });
              }
            }, 0);
          } else {
            G.bestEvalCache = null;
          }
        }

        const showRt = NET.showRating;
        if (showRt) {
          const R = RTNG[ri];
          let html = `<span class="${R.c}">${R.s} ${R.l}</span>`;
          if (inCheck(G.brd, opp(G.turn)))
            html += ` <span class="ck">Check!</span>`;
          if (NET.mode !== "bot") {
            const isMyMove = movingCol === NET.myCol;
            html = isMyMove ? `<b>You:</b> ${html}` : `<b>Opp:</b> ${html}`;
          }
          document.getElementById("ratingEl").innerHTML = html;
          document.getElementById("mRt").innerHTML =
            `<span class="${RTNG[ri].c}">${RTNG[ri].s}</span>`;
        }
        if (NET.showEval && !fromNet) setEval(newEv);
        // ELO: update from move quality (only player's moves, not bot/net)
        if (!isBot && !fromNet) eloOnMove(ri);
        addNote(note, movingCol, G.hist.length, ri, showRt);
        G.hist.push(mv);
        G.turn = opp(movingCol);
        const wasCapOrPawn = cap || piece[1] === "P";
        G.halfMove = wasCapOrPawn ? 0 : G.halfMove + 1;
        const posKey =
          G.brd.map((r) => r.join(",")).join("|") +
          ";" +
          G.turn +
          ";" +
          JSON.stringify(G.castl);
        G.posHist.push(posKey);
        const repCount = G.posHist.filter((k) => k === posKey).length;
        if (!fromNet && NET.mode !== "bot" && NET.conn) {
          // mv.promo is set above if promotion occurred ‚Äî receiver uses it directly
          netSend({
            type: "move",
            mv,
            timers: NET.timers,
            castl: G.castl,
            eval: newEv,
            ri,
            showRt: NET.showRating,
          });
        }
        if (G.halfMove >= 100) {
          endGame("fifty", "");
          return;
        }
        if (repCount >= 3) {
          endGame("repetition", "");
          return;
        }
        if (isInsufficientMaterial(G.brd)) {
          endGame("insufficient", "");
          return;
        }
        const nextFrz = G.turn === "w" ? G.frz.byB : G.frz.byW;
        const nextMs = allMoves(G.brd, G.turn, G.castl, nextFrz);
        if (!nextMs.length) {
          endGame(
            inCheck(G.brd, G.turn) ? "checkmate" : "stalemate",
            opp(G.turn),
          );
          return;
        }
        if (NET.mode === "local" && !G.over) flipped = G.turn === "b";

        // Sounds
        if (flag === "cs" || flag === "cl") playSound("castle");
        else if (cap) playSound("capture");
        else playSound("move");
        if (inCheck(G.brd, G.turn)) playSound("check");

        render();
        updStatus();
        updCaps();
        if (NET.timeCtrl && !G.over) startTurnTimer(G.turn);

        // ‚îÄ‚îÄ Execute pre-move chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // myCol = kolor gracza (nie bota) kt√≥ry ustawi≈Ç pre-move
        if (PMQUEUE.length > 0 && !G.over) {
          const pmCol =
            NET.mode === "bot" ? "w" : NET.mode === "local" ? null : NET.myCol;
          // W trybie local pre-move nie ma sensu (zawsze moja tura)
          if (pmCol && G.turn === pmCol) {
            const pm = PMQUEUE.shift();
            PMSEL = null;
            pmSync();
            const myFrz = G.turn === "w" ? G.frz.byB : G.frz.byW;
            const piece = G.brd[pm.fr][pm.fc];
            // Figura musi nale≈ºeƒá do mnie i staƒá na spodziewanym polu
            if (piece && piece[0] === G.turn) {
              const validMoves = movesFrom(G.brd, pm.fr, pm.fc, G.castl, myFrz);
              // Szukaj ruchu na docelowe pole ‚Äî niewa≈ºne czy tam stoi figura czy nie
              // (sytuacja mog≈Ça siƒô zmieniƒá ‚Äî bicie zniknƒô≈Ço, ale ruch pusty jest legalny)
              const pmv = validMoves.find(
                (m) => m.tr === pm.tr && m.tc === pm.tc,
              );
              if (pmv) {
                G.sel = null;
                G.poss = [];
                // Small delay ensures render completes, then execute premove
                setTimeout(() => {
                  if (!G.over && G.turn === pmCol) playMove(pmv, false, false);
                }, 50);
                return;
              }
            }
            // Ten krok nielegalny ‚Üí ca≈Çy ≈Ça≈Ñcuch odpada
            PMQUEUE = [];
            PMSEL = null;
            pmSync();
            render();
          }
        }

        if (NET.mode === "bot" && G.turn === "b" && !G.over) {
          document.getElementById("thkEl").classList.add("on");
          document.getElementById("mThk").classList.add("on");
          const delay = [300, 500, 700, 1000, 1400][botLevel - 1];
          setTimeout(runBot, delay);
        }
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // PROMOTION
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function doPromo(col) {
        return new Promise((res) => {
          promoOk = res;
          const pcs =
            col === "w" ? ["wQ", "wR", "wB", "wN"] : ["bQ", "bR", "bB", "bN"];
          const box = document.getElementById("promoBox");
          box.innerHTML = "";
          pcs.forEach((pc) => {
            const d = document.createElement("div");
            d.className = "pp";
            d.textContent = SYM[pc];
            d.style.color = col === "w" ? "#fff" : "#1a0a00";
            d.addEventListener("click", () => {
              document.getElementById("promoModal").classList.remove("on");
              if (promoOk) {
                promoOk(pc);
                promoOk = null;
              }
            });
            box.appendChild(d);
          });
          document.getElementById("promoModal").classList.add("on");
        });
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // BOT
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let _botAbort = false;
      function runBot() {
        document.getElementById("thkEl").classList.add("on");
        document.getElementById("mThk").classList.add("on");
        _botAbort = false;
        const delay = [150, 250, 400, 600, 900][botLevel - 1] || 300;
        setTimeout(() => _botAsync(G.brd, G.castl, G.frz.byW, botLevel), delay);
      }
      function _botAsync(brd, castl, frzW, level) {
        if (_botAbort || G.over || G.turn !== "b" || NET.mode !== "bot") return;
        const ms = allMoves(brd, "b", castl, frzW);
        if (!ms.length) {
          postBotMove(null);
          return;
        }
        if (level === 1) {
          const nc = ms.filter((m) => !brd[m.tr][m.tc]);
          const pool = nc.length && Math.random() < 0.85 ? nc : ms;
          postBotMove(pool[Math.floor(Math.random() * pool.length)]);
          return;
        }
        if (level === 2) {
          let best = ms[Math.floor(Math.random() * ms.length)];
          if (Math.random() > 0.55) {
            let bsc = -Infinity;
            for (const mv of ms) {
              const cap = brd[mv.tr][mv.tc];
              const sc = cap ? VAL[cap[1]] || 0 : Math.random() * 30 - 15;
              if (sc > bsc) {
                bsc = sc;
                best = mv;
              }
            }
          }
          postBotMove(best);
          return;
        }
        const depth = [0, 0, 0, 2, 3, 4][level] || 2; // deeper search levels
        const noise = [0, 0, 0, 0.06, 0.02, 0][level] || 0;
        const timeLimit = [0, 0, 0, 500, 1000, 2000][level] || 700;
        const deadline = Date.now() + timeLimit;
        ms.sort(
          (a, b) =>
            (brd[b.tr][b.tc] ? VAL[brd[b.tr][b.tc][1]] || 0 : 0) -
            (brd[a.tr][a.tc] ? VAL[brd[a.tr][a.tc][1]] || 0 : 0),
        );
        let bestMove = ms[0],
          bestScore = -Infinity,
          idx = 0;
        function step() {
          if (_botAbort) return;
          const chunkEnd = Math.min(idx + 3, ms.length);
          while (idx < chunkEnd) {
            const mv = ms[idx++];
            const nb = cp(brd),
              nc = { ...castl },
              p = brd[mv.fr][mv.fc];
            if (p === "bK") {
              nc.bK = false;
              nc.bQ = false;
            }
            applyMv(nb, mv, "b");
            const nf = calcFrz(nb);
            let sc = -abDeep(
              nb,
              depth - 1,
              -Infinity,
              Infinity,
              "w",
              nc,
              nf.byW,
              1,
              deadline,
            );
            if (noise) sc += (Math.random() * 2 - 1) * noise * 500;
            if (sc > bestScore) {
              bestScore = sc;
              bestMove = mv;
            }
          }
          if (idx >= ms.length || Date.now() > deadline) postBotMove(bestMove);
          else setTimeout(step, 0);
        }
        step();
      }
      function postBotMove(mv) {
        document.getElementById("thkEl").classList.remove("on");
        document.getElementById("mThk").classList.remove("on");
        if (mv && !G.over && G.turn === "b" && NET.mode === "bot")
          playMove(mv, true, false);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // PRE-MOVE ‚Äî all pieces, all modes, chess.com style
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚îÄ‚îÄ Pre-move chain helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // PMQUEUE = [{fr,fc,tr,tc}, ...] ‚Äî chain of moves to execute in order
      // PMSEL   = {fr,fc,poss:[]} | null ‚Äî currently highlighted source (picking next step)
      // PREMOVE = legacy compat alias (first item in queue, or empty)

      function pmClear() {
        PMQUEUE = [];
        PMSEL = null;
        PREMOVE = { active: false, fr: -1, fc: -1, tr: -1, tc: -1, poss: [] };
        render();
      }
      function pmSync() {
        // Keep PREMOVE in sync with first queued item (legacy code still uses PREMOVE)
        if (PMQUEUE.length > 0) {
          const q = PMQUEUE[0];
          PREMOVE = {
            active: true,
            fr: q.fr,
            fc: q.fc,
            tr: q.tr,
            tc: q.tc,
            poss: [],
          };
        } else {
          PREMOVE = { active: false, fr: -1, fc: -1, tr: -1, tc: -1, poss: [] };
        }
      }
      // Called when user picks a destination during pre-move setup
      // Adds to queue, then starts picking next step from that destination
      function pmAddStep(fr, fc, tr, tc, brdState, col) {
        const simBrd = brdSim(brdState, fr, fc, tr, tc);
        // Store simulated board state WITH this step so later steps can build on it
        PMQUEUE.push({ fr, fc, tr, tc, brd: simBrd });
        pmSync();
        // Auto-select the piece at its new position for next step
        const piece = brdState[fr][fc];
        if (piece) {
          const nextPoss = premovePoss(tr, tc, simBrd, col);
          PMSEL = { fr: tr, fc: tc, poss: nextPoss, brd: simBrd };
        } else {
          PMSEL = null;
        }
        render();
      }
      // Simulate one move on a board without modifying it (lightweight, no copy for queens/sliders)
      function brdSim(brd, fr, fc, tr, tc) {
        // Fast shallow copy of 2D array
        const b = brd.map((r) => r.slice());
        const p = b[fr][fc];
        b[tr][tc] = p;
        b[fr][fc] = null;
        // Handle castling geometry
        if (p && p[1] === "K") {
          const rk = p[0] === "w" ? 7 : 0;
          if (fr === rk && fc === 4 && tc === 6) {
            b[rk][5] = p[0] + "R";
            b[rk][7] = null;
          }
          if (fr === rk && fc === 4 && tc === 2) {
            b[rk][3] = p[0] + "R";
            b[rk][0] = null;
          }
        }
        // Pawn promotion ‚Üí queen for simulation purposes
        if (p && p[1] === "P" && (tr === 0 || tr === 7)) b[tr][tc] = p[0] + "Q";
        return b;
      }
      // Legacy alias
      function setPremove(fr, fc, tr, tc) {
        const b = brdSim(G.brd, fr, fc, tr, tc);
        PMQUEUE = [{ fr, fc, tr, tc, brd: b }];
        PMSEL = null;
        pmSync();
        render();
      }
      function clearPremove() {
        pmClear();
      }
      // Fast premove squares ‚Äî pure geometry, no board copy, no check validation
      // brd = board to use (current or hypothetical), col = moving color
      function premovePoss(fr, fc, brd, col) {
        if (!brd) brd = G.brd;
        const p = brd[fr][fc];
        if (!p) return [];
        if (!col) col = p[0];
        const type = p[1];
        const sq = [];
        function ok(tr, tc) {
          if (tr < 0 || tr >= 8 || tc < 0 || tc >= 8) return false;
          const t = brd[tr][tc];
          if (t && t[0] === col) return false; // own piece
          if (t && t[1] === type && type !== "P") return false; // same-type capture banned
          return true;
        }
        function add(tr, tc) {
          if (ok(tr, tc)) sq.push({ tr, tc });
        }
        if (type === "P") {
          const d = col === "w" ? -1 : 1,
            sR = col === "w" ? 6 : 1;
          const nr = fr + d;
          if (nr >= 0 && nr < 8) {
            if (!brd[nr][fc]) {
              add(nr, fc);
              if (fr === sR && !brd[fr + 2 * d][fc]) add(fr + 2 * d, fc);
            }
            for (const dc of [-1, 1]) {
              const nc = fc + dc;
              if (nc >= 0 && nc < 8 && brd[nr][nc] && brd[nr][nc][0] !== col)
                add(nr, nc);
            }
          }
        } else if (type === "N") {
          for (const [dr, dc] of [
            [2, 1],
            [2, -1],
            [-2, 1],
            [-2, -1],
            [1, 2],
            [1, -2],
            [-1, 2],
            [-1, -2],
          ])
            add(fr + dr, fc + dc);
        } else if (type === "K") {
          for (const [dr, dc] of [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1],
          ])
            add(fr + dr, fc + dc);
          const rk = col === "w" ? 7 : 0;
          if (fr === rk && fc === 4) {
            if (!brd[rk][5] && !brd[rk][6]) sq.push({ tr: rk, tc: 6 });
            if (!brd[rk][3] && !brd[rk][2] && !brd[rk][1])
              sq.push({ tr: rk, tc: 2 });
          }
        } else {
          const D =
            type === "B"
              ? [
                  [1, 1],
                  [1, -1],
                  [-1, 1],
                  [-1, -1],
                ]
              : type === "R"
                ? [
                    [1, 0],
                    [-1, 0],
                    [0, 1],
                    [0, -1],
                  ]
                : [
                    [1, 1],
                    [1, -1],
                    [-1, 1],
                    [-1, -1],
                    [1, 0],
                    [-1, 0],
                    [0, 1],
                    [0, -1],
                  ];
          for (const [dr, dc] of D) {
            let nr = fr + dr,
              nc = fc + dc;
            while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
              const t = brd[nr][nc];
              if (t) {
                if (t[0] !== col && t[1] !== type) sq.push({ tr: nr, tc: nc });
                break;
              }
              sq.push({ tr: nr, tc: nc });
              nr += dr;
              nc += dc;
            }
          }
        }
        return sq;
      }
      // Who is "me" for premove purposes
      function myColor() {
        if (NET.mode === "local") return G.turn; // local: always current player
        if (NET.mode === "bot") return "w"; // vs bot: always white
        return NET.myCol; // online: my assigned color
      }
      // Is it currently my turn to move?
      function isMyTurn() {
        if (G.over) return false;
        if (NET.mode === "local") return true;
        if (NET.mode === "bot") return G.turn === "w";
        return G.turn === NET.myCol;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // RENDER
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function buildLabels() {
        const labLeft = document.getElementById("labLeft");
        const labRight = document.getElementById("labRight");
        const labTop = document.getElementById("labTop");
        const labBot = document.getElementById("labBot");
        [labLeft, labRight, labTop, labBot].forEach((el) => {
          if (el) el.innerHTML = "";
        });

        // Rangi (1-8) ‚Äî zawsze po lewej stronie wizualnej
        // !flipped: labLeft jest fizycznie po lewej. i=0(g√≥ra)‚Üí8, i=7(d√≥≈Ç)‚Üí1
        // flipped: ca≈Çy wrapper obr√≥cony 180¬∞, wiƒôc labLeft jest po prawej wizualnie
        //   ‚Üí wpisz do labRight; rotacja odwr√≥ci kolejno≈õƒá DOM:
        //   chcemy 8 na g√≥rze wizualnie ‚Üí w DOM i=0‚Üí1, i=7‚Üí8 (rotacja: 8 na g√≥rze ‚úì)
        if (!flipped) {
          if (labLeft)
            for (let i = 0; i < 8; i++) {
              const d = document.createElement("div");
              d.className = "blbl r";
              d.textContent = 8 - i;
              labLeft.appendChild(d);
            }
        } else {
          if (labRight)
            for (let i = 0; i < 8; i++) {
              const d = document.createElement("div");
              d.className = "blbl r";
              d.textContent = 8 - i;
              labRight.appendChild(d);
            }
        }

        // Pliki (a-h) ‚Äî zawsze na dole wizualnym
        // !flipped: labBot fizycznie na dole. i=0‚Üía, i=7‚Üíh
        // flipped: labTop staje siƒô do≈Çem po rotacji; rotacja odwr√≥ci kolejno≈õƒá
        //   chcemy a po lewej wizualnie ‚Üí w DOM i=0‚Üíh, i=7‚Üía (rotacja: a po lewej ‚úì)
        if (!flipped) {
          if (labBot)
            for (let i = 0; i < 8; i++) {
              const d = document.createElement("div");
              d.className = "blbl f";
              d.textContent = FILES[i];
              labBot.appendChild(d);
            }
        } else {
          if (labTop)
            for (let i = 0; i < 8; i++) {
              const d = document.createElement("div");
              d.className = "blbl f";
              d.textContent = FILES[i];
              labTop.appendChild(d);
            }
        }

        // b-top i b-bot majƒÖ margin-left:var(--lbl) (dla labLeft gdy !flipped)
        // gdy flipped labLeft jest pusty ‚Üí usu≈Ñ ten margin
        const bTopEl = document.querySelector(".b-top");
        const bBotEl = document.querySelector(".b-bot");
        if (bTopEl) bTopEl.style.marginLeft = flipped ? "0" : "";
        if (bBotEl) bBotEl.style.marginLeft = flipped ? "0" : "";
      }

      function render() {
        const bwrapEl = document.getElementById("bwrap");
        if (bwrapEl) {
          const wasFlipped = bwrapEl.classList.contains("flipped");
          if (flipped) bwrapEl.classList.add("flipped");
          else bwrapEl.classList.remove("flipped");
          if (
            flipped !== wasFlipped ||
            !document.getElementById("labLeft").children.length
          ) {
            buildLabels();
          }
        }
        const boardEl = document.getElementById("board");
        const frzSet = new Set(G.frz.all);
        const possSet = new Set(G.poss.map((m) => m.tr * 8 + m.tc));
        // Pre-move chain: collect all squares involved
        // All queued from/to squares
        const pmFromSet = new Set(PMQUEUE.map((s) => s.fr * 8 + s.fc));
        const pmToSet = new Set(PMQUEUE.map((s) => s.tr * 8 + s.tc));
        // Poss dots for currently active PMSEL
        const prePossSet = new Set(
          PMSEL && PMSEL.poss ? PMSEL.poss.map((m) => m.tr * 8 + m.tc) : [],
        );
        // All destinations in queue shown as premove-to (brighter orange)
        const pmDestSet = new Set(PMQUEUE.map((s) => s.tr * 8 + s.tc));
        // Last destination per piece ‚Äî for "continue journey" highlight
        const pmSelSrc = PMSEL ? PMSEL.fr * 8 + PMSEL.fc : -1;
        let kchk = -1;
        if (inCheck(G.brd, G.turn))
          for (let r = 0; r < 8; r++)
            for (let c = 0; c < 8; c++)
              if (G.brd[r][c] === G.turn + "K") kchk = r * 8 + c;
        const squares = boardEl.children;
        if (squares.length === 64) {
          for (let dr = 0; dr < 8; dr++)
            for (let dc = 0; dc < 8; dc++) {
              const r = dr,
                c = dc,
                sq = squares[dr * 8 + dc],
                k = r * 8 + c,
                p = G.brd[r][c];
              let cls = "sq " + ((r + c) % 2 === 0 ? "lt" : "dk");
              if (
                G.lastMv &&
                (k === G.lastMv.fr * 8 + G.lastMv.fc ||
                  k === G.lastMv.tr * 8 + G.lastMv.tc)
              )
                cls += " lm";
              if (G.sel && r === G.sel.r && c === G.sel.c) cls += " sel";
              if (k === kchk) cls += " chk";
              else if (frzSet.has(k)) cls += " frz";
              if (possSet.has(k)) cls += p ? " cring" : " dot";
              // Pre-move chain highlights
              if (pmFromSet.has(k)) cls += " premove-from"; // sources
              if (pmDestSet.has(k)) cls += " premove-to"; // all destinations (bright orange)
              if (k === pmSelSrc) cls += " premove-from"; // active selection source
              if (prePossSet.has(k) && !pmDestSet.has(k))
                cls += p ? " pre-cring" : " pre-dot"; // next step dots
              if (sq.className !== cls) sq.className = cls;
              const existing = sq.querySelector(".pc");
              if (p) {
                const sym = SYM[p],
                  pcls = "pc " + (p[0] === "w" ? "pw" : "pb");
                if (existing) {
                  if (existing.textContent !== sym) existing.textContent = sym;
                  if (existing.className !== pcls) existing.className = pcls;
                } else {
                  sq.innerHTML = "";
                  const pe = document.createElement("span");
                  pe.className = pcls;
                  pe.textContent = sym;
                  sq.appendChild(pe);
                }
                const hasFriz = !!sq.querySelector(".friz");
                if (frzSet.has(k) && !hasFriz) {
                  const fi = document.createElement("span");
                  fi.className = "friz";
                  fi.textContent = "‚ùÑ";
                  sq.appendChild(fi);
                } else if (!frzSet.has(k) && hasFriz)
                  sq.querySelector(".friz").remove();
              } else {
                if (sq.innerHTML !== "") sq.innerHTML = "";
              }
              sq.onclick = () => handleClick(r, c);
            }
        } else {
          boardEl.innerHTML = "";
          buildLabels();
          for (let dr = 0; dr < 8; dr++)
            for (let dc = 0; dc < 8; dc++) {
              const r = dr,
                c = dc,
                sq = document.createElement("div");
              sq.className = "sq " + ((r + c) % 2 === 0 ? "lt" : "dk");
              sq.dataset.r = r;
              sq.dataset.c = c;
              const k = r * 8 + c;
              if (
                G.lastMv &&
                (k === G.lastMv.fr * 8 + G.lastMv.fc ||
                  k === G.lastMv.tr * 8 + G.lastMv.tc)
              )
                sq.classList.add("lm");
              if (G.sel && r === G.sel.r && c === G.sel.c)
                sq.classList.add("sel");
              if (k === kchk) sq.classList.add("chk");
              else if (frzSet.has(k)) sq.classList.add("frz");
              const p = G.brd[r][c];
              if (possSet.has(k)) sq.classList.add(p ? "cring" : "dot");
              if (pmFromSet.has(k) || k === pmSelSrc)
                sq.classList.add("premove-from");
              if (pmDestSet.has(k)) sq.classList.add("premove-to");
              if (prePossSet.has(k) && !pmDestSet.has(k))
                sq.classList.add(p ? "pre-cring" : "pre-dot");
              if (p) {
                const pe = document.createElement("span");
                pe.className = "pc " + (p[0] === "w" ? "pw" : "pb");
                pe.textContent = SYM[p];
                sq.appendChild(pe);
                if (frzSet.has(k)) {
                  const fi = document.createElement("span");
                  fi.className = "friz";
                  fi.textContent = "‚ùÑ";
                  sq.appendChild(fi);
                }
              }
              sq.onclick = () => handleClick(r, c);
              boardEl.appendChild(sq);
            }
        }
        const myCol = NET.myCol || "w",
          opCol = opp(myCol);
        let topName, botName;
        if (NET.mode === "local") {
          const topCol = flipped ? "w" : "b",
            botCol = flipped ? "b" : "w";
          topName =
            (topCol === "w" ? "White" : "Black") +
            (topCol === "w" ? " ‚ôî" : " ‚ôö");
          botName =
            (botCol === "w" ? "White" : "Black") +
            (botCol === "w" ? " ‚ôî" : " ‚ôö");
        } else if (NET.mode === "bot") {
          topName = "Bot (Black)";
          botName = "You (White)";
        } else {
          topName = (NET.oppName || "Opponent") + (opCol === "w" ? " ‚ôî" : " ‚ôö");
          botName = (NET.myName || "You") + (myCol === "w" ? " ‚ôî" : " ‚ôö");
        }
        const pTop = document.getElementById("pnmTop");
        if (pTop) pTop.textContent = topName;
        const pBot = document.getElementById("pnmBot");
        if (pBot) pBot.textContent = botName;
        updMobile();
      }

      // ‚îÄ‚îÄ Pre-move queue helpers (top-level) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function pmLastStepEndingAt(r, c) {
        for (let i = PMQUEUE.length - 1; i >= 0; i--)
          if (PMQUEUE[i].tr === r && PMQUEUE[i].tc === c) return i;
        return -1;
      }
      function pmLastStepFrom(r, c) {
        for (let i = PMQUEUE.length - 1; i >= 0; i--)
          if (PMQUEUE[i].fr === r && PMQUEUE[i].fc === c) return i;
        return -1;
      }
      function pmQueueBrd() {
        return PMQUEUE.length > 0 ? PMQUEUE[PMQUEUE.length - 1].brd : G.brd;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // CLICK ‚Äî premove chain (chess.com style, all pieces/modes)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function handleClick(r, c) {
        if (G.over) return;
        const mc = myColor();
        const p = G.brd[r][c];
        const myTurn = isMyTurn();

        // ‚îÄ‚îÄ MY TURN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (myTurn) {
          pmClear(); // cancel any queued premoves when I actually interact
          const frz = mc === "w" ? G.frz.byB : G.frz.byW;
          if (G.sel) {
            const mv = G.poss.find((m) => m.tr === r && m.tc === c);
            if (mv) {
              G.sel = null;
              G.poss = [];
              playMove(mv, false, false);
              return;
            }
            if (p && p[0] === mc) {
              const isFrz =
                p[1] !== "P" && p[1] !== "K" && frz.includes(r * 8 + c);
              if (!isFrz) {
                G.sel = { r, c };
                G.poss = movesFrom(G.brd, r, c, G.castl, frz);
                render();
                return;
              }
            }
            G.sel = null;
            G.poss = [];
            render();
            return;
          }
          if (p && p[0] === mc) {
            const isFrz =
              p[1] !== "P" && p[1] !== "K" && frz.includes(r * 8 + c);
            if (isFrz) return;
            G.sel = { r, c };
            G.poss = movesFrom(G.brd, r, c, G.castl, frz);
            render();
          }
          return;
        }

        // ‚îÄ‚îÄ NOT MY TURN ‚Üí PRE-MOVE CHAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (NET.mode === "local") return;

        if (PMSEL) {
          const simBrd = PMSEL.brd || G.brd;

          // 1. Klik na tƒô samƒÖ figurƒô kt√≥rƒÖ masz zaznaczonƒÖ ‚Üí odznacz (ju≈º jeste≈õ na jej ostatniej pozycji)
          if (r === PMSEL.fr && c === PMSEL.fc) {
            PMSEL = null;
            render();
            return;
          }

          // 2. Klik na pomara≈Ñczowe pole (ostatni krok innej figury) ‚Üí kontynuuj tƒô figurƒô
          const endIdx = pmLastStepEndingAt(r, c);
          if (endIdx !== -1) {
            const brdThere = PMQUEUE[endIdx].brd;
            const poss = premovePoss(r, c, brdThere, mc);
            PMSEL = { fr: r, fc: c, poss, brd: brdThere };
            render();
            return;
          }

          // 3. Klik na w≈ÇasnƒÖ figurƒô (na symulowanej planszy) ‚Üí prze≈ÇƒÖcz zaznaczenie
          const simP = simBrd[r] && simBrd[r][c];
          if (simP && simP[0] === mc) {
            const poss = premovePoss(r, c, simBrd, mc);
            PMSEL = { fr: r, fc: c, poss, brd: simBrd };
            render();
            return;
          }

          // 4. Klik na pole w zasiƒôgu figury (w prePossSet) ‚Üí dodaj krok
          const inPoss =
            PMSEL.poss && PMSEL.poss.some((m) => m.tr === r && m.tc === c);
          if (inPoss) {
            pmAddStep(PMSEL.fr, PMSEL.fc, r, c, PMSEL.brd || G.brd, mc);
            return;
          }

          // 5. Klik poza zasiƒôgiem, puste pole lub figura wroga ‚Üí NIC (dots zostajƒÖ)
          return;
        }

        // Brak aktywnego zaznaczenia ‚Äî klik na w≈ÇasnƒÖ figurƒô startuje pre-move
        if (p && p[0] === mc) {
          // ≈öled≈∫ gdzie ta figura wylƒÖdowa≈Ça po wszystkich krokach w kolejce
          // Figura na (r,c) mog≈Ça zrobiƒá: r‚ÜíA‚ÜíB‚ÜíC ‚Äî teleportuj do C
          let endR = r,
            endC = c,
            lastIdx = -1;
          let changed = true;
          while (changed) {
            changed = false;
            for (let i = 0; i < PMQUEUE.length; i++) {
              if (PMQUEUE[i].fr === endR && PMQUEUE[i].fc === endC) {
                endR = PMQUEUE[i].tr;
                endC = PMQUEUE[i].tc;
                lastIdx = i;
                changed = true;
                break;
              }
            }
          }
          if (lastIdx !== -1) {
            // Figura ma kroki ‚Äî teleportuj do ostatniej zakolejkowanej pozycji
            const lastStep = PMQUEUE[lastIdx];
            const poss = premovePoss(
              lastStep.tr,
              lastStep.tc,
              lastStep.brd,
              mc,
            );
            PMSEL = {
              fr: lastStep.tr,
              fc: lastStep.tc,
              poss,
              brd: lastStep.brd,
            };
          } else {
            // Figura nie ma krok√≥w ‚Äî normalny start
            const poss = premovePoss(r, c, G.brd, mc);
            PMSEL = { fr: r, fc: c, poss, brd: G.brd };
          }
          render();
        }
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // DRAG & DROP ‚Äî premove for ALL pieces/modes
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function getXY(e) {
        if (e.touches && e.touches.length)
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if (e.changedTouches && e.changedTouches.length)
          return {
            x: e.changedTouches[0].clientX,
            y: e.changedTouches[0].clientY,
          };
        return { x: e.clientX, y: e.clientY };
      }
      function brdSq(x, y) {
        const rect = document.getElementById("board").getBoundingClientRect();
        let dc = Math.floor((x - rect.left) / (rect.width / 8)),
          dr = Math.floor((y - rect.top) / (rect.height / 8));
        if (dc < 0 || dc >= 8 || dr < 0 || dr >= 8) return null;
        if (flipped) {
          dr = 7 - dr;
          dc = 7 - dc;
        }
        return { r: dr, c: dc };
      }
      function myTurnNow() {
        return isMyTurn();
      }

      function startDrag(r, c, x, y) {
        const p = G.brd[r][c];
        if (!p) return false;
        const mc = myColor();
        const myTurn = isMyTurn();

        // Pre-move: only via click, not drag ‚Äî so ignore drag when not my turn
        if (!myTurn) return false;

        // NORMAL drag ‚Äî my turn
        if (!myTurn) return false;
        if (p[0] !== mc) return false;
        const frz = mc === "w" ? G.frz.byB : G.frz.byW;
        const isFrz = p[1] !== "P" && p[1] !== "K" && frz.includes(r * 8 + c);
        if (isFrz) return false;
        const poss = movesFrom(G.brd, r, c, G.castl, frz);
        const gh = document.createElement("span");
        gh.className = "ghost";
        gh.textContent = SYM[p];
        gh.style.fontSize = "calc(var(--sq)*.85)";
        gh.style.color = p[0] === "w" ? "#fff" : "#1a0a00";
        gh.style.filter =
          p[0] === "w"
            ? "drop-shadow(0 0 1px #000) drop-shadow(1px 1px 0 #000)"
            : "drop-shadow(0 0 1px rgba(255,255,255,.8))";
        gh.style.left = x + "px";
        gh.style.top = y + "px";
        document.body.appendChild(gh);
        DR.on = true;
        DR.ghost = gh;
        DR.fr = r;
        DR.fc = c;
        DR.poss = poss;
        DR.sx = x;
        DR.sy = y;
        DR.moved = false;
        DR.isPremove = false;
        G.sel = { r, c };
        G.poss = poss;
        render();
        const sqEl = document.querySelector(
          `.sq[data-r="${r}"][data-c="${c}"]`,
        );
        if (sqEl) {
          const pe = sqEl.querySelector(".pc");
          if (pe) pe.classList.add("dim");
        }
        return true;
      }
      function moveDrag(x, y) {
        if (!DR.on) return;
        DR.ghost.style.left = x + "px";
        DR.ghost.style.top = y + "px";
        if (Math.abs(x - DR.sx) > 4 || Math.abs(y - DR.sy) > 4) DR.moved = true;
      }
      function endDrag(x, y) {
        if (!DR.on) return;
        DR.on = false;
        DR.ghost.remove();
        DR.ghost = null;
        const sq = brdSq(x, y);
        if (DR.isPremove) {
          pmClear();
          render();
          return;
        } // premove only via click
        const mv = sq && DR.poss.find((m) => m.tr === sq.r && m.tc === sq.c);
        if (mv) {
          G.sel = null;
          G.poss = [];
          playMove(mv, false, false);
        } else if (DR.moved) {
          G.sel = null;
          G.poss = [];
          render();
        }
      }

      const boardEl = document.getElementById("board");
      boardEl.addEventListener(
        "mousedown",
        (e) => {
          if (e.button !== 0) return;
          const sq = e.target.closest(".sq");
          if (!sq) return;
          e.preventDefault();
          mDown = { r: parseInt(sq.dataset.r), c: parseInt(sq.dataset.c) };
          mXY = { x: e.clientX, y: e.clientY };
        },
        { passive: false },
      );
      document.addEventListener("mousemove", (e) => {
        if (DR.on) {
          moveDrag(e.clientX, e.clientY);
          return;
        }
        if (!mDown) return;
        if (
          Math.abs(e.clientX - mXY.x) > 6 ||
          Math.abs(e.clientY - mXY.y) > 6
        ) {
          startDrag(mDown.r, mDown.c, e.clientX, e.clientY);
          mDown = null;
        }
      });
      document.addEventListener("mouseup", (e) => {
        mDown = null;
        if (DR.on) endDrag(e.clientX, e.clientY);
      });
      boardEl.addEventListener(
        "touchstart",
        (e) => {
          const sq = e.target.closest(".sq");
          if (!sq) return;
          const { x, y } = getXY(e);
          tXY = { x, y };
          tMoved = false;
          tTimer = setTimeout(() => {
            if (tMoved) return;
            if (navigator.vibrate) navigator.vibrate(20);
            startDrag(parseInt(sq.dataset.r), parseInt(sq.dataset.c), x, y);
          }, 150);
        },
        { passive: true },
      );
      document.addEventListener(
        "touchmove",
        (e) => {
          const { x, y } = getXY(e);
          if (tXY && (Math.abs(x - tXY.x) > 9 || Math.abs(y - tXY.y) > 9)) {
            tMoved = true;
            if (!DR.on) {
              clearTimeout(tTimer);
              tTimer = null;
              return;
            }
          }
          if (!DR.on) return;
          e.preventDefault();
          moveDrag(x, y);
        },
        { passive: false },
      );
      document.addEventListener(
        "touchend",
        (e) => {
          clearTimeout(tTimer);
          tTimer = null;
          if (DR.on) {
            const { x, y } = getXY(e);
            e.preventDefault();
            endDrag(x, y);
          }
          tXY = null;
        },
        { passive: false },
      );
      document.addEventListener("touchcancel", () => {
        clearTimeout(tTimer);
        tTimer = null;
        if (DR.on) {
          DR.on = false;
          DR.ghost && DR.ghost.remove();
          DR.ghost = null;
          G.sel = null;
          G.poss = [];
          render();
        }
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // STATUS / CAPS / EVAL
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function updStatus() {
        if (G.over) {
          document.getElementById("statusEl").innerHTML =
            '<span style="color:var(--gold)">Game Over</span>';
          return;
        }
        const chk = inCheck(G.brd, G.turn),
          fz = G.frz.all.length;
        const isMyTurn = myTurnNow();
        const turnLabel =
          NET.mode === "local"
            ? (G.turn === "w" ? "White" : "Black") + "'s turn"
            : isMyTurn
              ? "Your turn"
              : NET.mode === "bot"
                ? "Bot (Black)"
                : NET.oppName + "'s turn";
        const dot =
          G.turn === "w"
            ? '<span class="tdot" style="background:#eee;border:2px solid #aaa"></span>'
            : '<span class="tdot" style="background:#222;border:2px solid #555"></span>';
        let h = dot + turnLabel;
        if (chk)
          h += ` <span style="color:var(--red);font-weight:700">CHECK!</span>`;
        if (fz) h += ` <span style="color:var(--acc)">‚ùÑ${fz}</span>`;
        if (PREMOVE.active)
          h += ` <span style="color:#ffd700;font-size:.7rem">‚ö°pre-move</span>`;
        document.getElementById("statusEl").innerHTML = h;
      }
      function updMobile() {
        const chk = inCheck(G.brd, G.turn),
          fz = G.frz.all.length;
        const isMyTurn = myTurnNow();
        let st = G.over
          ? "Game Over"
          : NET.mode === "local"
            ? (G.turn === "w" ? "White" : "Black") + "'s turn"
            : isMyTurn
              ? "Your turn"
              : NET.mode === "bot"
                ? "Bot ‚ôü"
                : NET.oppName;
        if (!G.over && chk) st += " ‚ö†";
        if (!G.over && fz) st += " ‚ùÑ" + fz;
        if (PREMOVE.active) st += " ‚ö°";
        document.getElementById("mSt").textContent = st;
        const ev = G.prevEval;
        document.getElementById("mEv").textContent =
          Math.abs(ev) > 9000
            ? "M"
            : (ev >= 0 ? "+" : "") + (ev / 100).toFixed(1);
      }
      function updCaps() {
        const S = (x) => x.map((p) => SYM[p] || "").join("");
        document.getElementById("capW").textContent = S(G.capW);
        document.getElementById("capB").textContent = S(G.capB);
        const wv = G.capW.reduce((s, p) => s + (VAL[p[1]] || 0), 0),
          bv = G.capB.reduce((s, p) => s + (VAL[p[1]] || 0), 0);
        document.getElementById("scW").textContent =
          wv > bv ? "+" + (wv - bv) : "";
        document.getElementById("scB").textContent =
          bv > wv ? "+" + (bv - wv) : "";
      }
      function setEval(score) {
        const brd = document.getElementById("board"),
          et = document.getElementById("evtrack");
        if (brd && et && window.innerWidth > 700) {
          const h = brd.getBoundingClientRect().height;
          if (h > 0) et.style.height = h + "px";
        }
        // Mate scores (¬±19000) ‚Üí show full bar
        const isMate = Math.abs(score) > 9000;
        const clamp = isMate
          ? score > 0
            ? 2000
            : -2000
          : Math.max(-2000, Math.min(2000, score));
        const wp = Math.round(50 + (clamp / 2000) * 46);
        const bp = 100 - wp;
        const W = document.getElementById("evW"),
          B = document.getElementById("evB");
        const isMob = window.innerWidth <= 700;
        if (isMob) {
          if (W) {
            W.style.width = wp + "%";
            W.style.height = "100%";
          }
          if (B) {
            B.style.width = bp + "%";
            B.style.height = "100%";
          }
        } else {
          if (W) {
            W.style.height = wp + "%";
            W.style.width = "100%";
          }
          if (B) {
            B.style.height = bp + "%";
            B.style.width = "100%";
          }
        }
        const txt = isMate
          ? "M"
          : (score >= 0 ? "+" : "") + (score / 100).toFixed(1);
        const sc = document.getElementById("evSc");
        if (sc) sc.textContent = txt;
        const wAdv = score > 30,
          bAdv = score < -30;
        const lb = document.getElementById("evLblB"),
          lw = document.getElementById("evLblW");
        if (lb)
          lb.textContent = bAdv
            ? isMate
              ? "M"
              : (-score / 100).toFixed(1)
            : "";
        if (lw)
          lw.textContent = wAdv
            ? isMate
              ? "M"
              : (score / 100).toFixed(1)
            : "";
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // NOTATION
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function buildNote(brd, mv, col) {
        const { fr, fc, tr, tc, flag } = mv;
        if (flag === "cs") return "O-O";
        if (flag === "cl") return "O-O-O";
        const p = brd[fr][fc],
          t = p[1],
          cap = brd[tr][tc],
          to = FILES[tc] + RANKS[tr];
        if (t === "P") return cap ? FILES[fc] + "x" + to : to;
        return t + (cap ? "x" : "") + to;
      }
      function addNote(n, col, idx, ri, showRt) {
        const el = document.getElementById("movesEl"),
          mn = Math.floor(idx / 2) + 1;
        const s = document.createElement("span");
        s.style.cssText = "white-space:nowrap;padding:1px 3px";
        let icon = "";
        if (showRt && ri !== null && ri !== undefined) {
          const R = RTNG[ri];
          icon = `<span class="${R.c}" style="font-size:.68rem;margin-left:1px" title="${R.l}">${R.s}</span>`;
        }
        s.innerHTML =
          col === "w"
            ? `<span class="mn">${mn}.</span><span class="mw"> ${n}</span>${icon}`
            : `<span class="mb2"> ${n}</span>${icon}`;
        el.appendChild(s);
        el.scrollTop = el.scrollHeight;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // END GAME
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function stopAnim() {
        animH.forEach(clearTimeout);
        animH = [];
        animC.forEach((el) => {
          try {
            el.remove();
          } catch (e) {}
        });
        animC = [];
        animOn = false;
        document.querySelectorAll(".cfti").forEach((e) => e.remove());
      }
      function isInsufficientMaterial(brd) {
        const pieces = { w: [], b: [] };
        for (let r = 0; r < 8; r++)
          for (let c = 0; c < 8; c++) {
            const p = brd[r][c];
            if (!p) continue;
            pieces[p[0]].push({ type: p[1], r, c });
          }
        const w = pieces.w,
          b = pieces.b;
        if (w.length === 1 && b.length === 1) return true;
        if (
          w.length === 1 &&
          b.length === 2 &&
          (b[0].type === "B" ||
            b[0].type === "N" ||
            b[1].type === "B" ||
            b[1].type === "N")
        )
          return true;
        if (
          b.length === 1 &&
          w.length === 2 &&
          (w[0].type === "B" ||
            w[0].type === "N" ||
            w[1].type === "B" ||
            w[1].type === "N")
        )
          return true;
        if (w.length === 2 && b.length === 2) {
          const wb = w.find((p) => p.type === "B"),
            bb = b.find((p) => p.type === "B");
          if (wb && bb && (wb.r + wb.c) % 2 === (bb.r + bb.c) % 2) return true;
        }
        return false;
      }
      function endGame(reason, winner) {
        playSound("gameover");
        G.over = true;
        stopTimers();
        PMQUEUE = [];
        PMSEL = null;
        PREMOVE = { active: false, fr: -1, fc: -1, tr: -1, tc: -1, poss: [] };
        render();
        updStatus();
        const db = document.getElementById("drawOfferBanner");
        if (db) db.style.display = "none";
        eloOnGame(reason, winner);
        animOn = true;
        const cfg = {
          checkmate: {
            ti: "‚ôõ Checkmate!",
            su: (winner === "w" ? "White" : "Black") + " wins!",
            an: winner === NET.myCol ? "conf" : "fly",
          },
          stalemate: {
            ti: "¬Ω Stalemate",
            su: "Draw ‚Äî no legal moves",
            an: "pulse",
          },
          resign: {
            ti: "Resigned",
            su: (winner === "w" ? "Black" : "White") + " resigned",
            an: "fly",
          },
          draw: { ti: "¬Ω Draw", su: "Draw by agreement", an: "pulse" },
          timeout: {
            ti: "‚è∞ Time Out",
            su: (winner === "w" ? "White" : "Black") + " wins on time!",
            an: winner === NET.myCol ? "conf" : "fly",
          },
          fifty: { ti: "¬Ω Draw", su: "Draw ‚Äî 50-move rule", an: "pulse" },
          repetition: {
            ti: "¬Ω Draw",
            su: "Draw ‚Äî threefold repetition",
            an: "pulse",
          },
          insufficient: {
            ti: "¬Ω Draw",
            su: "Draw ‚Äî insufficient material",
            an: "pulse",
          },
        };
        const cf = cfg[reason] || cfg.stalemate;
        if (cf.an === "conf") {
          const sym = "‚ôî‚ôï‚ôñ‚ôó‚ôò‚ôô";
          for (let i = 0; i < 18; i++) {
            const h = setTimeout(() => {
              const el = document.createElement("span");
              el.className = "cfti";
              el.textContent = sym[Math.floor(Math.random() * sym.length)];
              el.style.left = Math.random() * 100 + "vw";
              el.style.color = `hsl(${40 + Math.random() * 20},80%,65%)`;
              el.style.animationDuration = 1.3 + Math.random() + "s";
              document.body.appendChild(el);
              animC.push(el);
              const rh = setTimeout(() => {
                try {
                  el.remove();
                } catch (e) {}
              }, 2200);
              animH.push(rh);
            }, i * 55);
            animH.push(h);
          }
          animH.push(
            setTimeout(() => {
              animOn = false;
            }, 2200),
          );
        } else if (cf.an === "fly") {
          const bd = document.getElementById("board");
          [...bd.querySelectorAll(".pc")].forEach((pe, i) => {
            const h = setTimeout(() => {
              const cl = pe.cloneNode(true),
                rect = pe.getBoundingClientRect();
              cl.style.cssText = `position:fixed;left:${rect.left}px;top:${rect.top}px;font-size:${rect.height * 0.7}px;z-index:700;pointer-events:none;animation:pfly ${0.7 + Math.random() * 0.5}s ease-out forwards`;
              document.body.appendChild(cl);
              animC.push(cl);
              const rh = setTimeout(() => {
                try {
                  cl.remove();
                } catch (e) {}
              }, 1300);
              animH.push(rh);
            }, i * 22);
            animH.push(h);
          });
          animH.push(
            setTimeout(() => {
              animOn = false;
            }, 1600),
          );
        } else {
          const bd = document.getElementById("board");
          [0, 260, 520, 780].forEach((t) => {
            const h = setTimeout(() => {
              bd.style.boxShadow = bd.style.boxShadow.includes("60px")
                ? "0 0 24px rgba(201,168,76,.15),0 8px 32px rgba(0,0,0,.8)"
                : "0 0 60px rgba(201,168,76,.7)";
            }, t);
            animH.push(h);
          });
          animH.push(
            setTimeout(() => {
              animOn = false;
            }, 850),
          );
        }
        const showRematch = NET.mode !== "bot" && NET.timeCtrl;
        animH.push(
          setTimeout(
            () => {
              document.getElementById("tTi").textContent = cf.ti;
              document.getElementById("tSu").textContent = cf.su;
              const tr2 = document.getElementById("tRematch");
              if (tr2) tr2.style.display = showRematch ? "" : "none";
              document.getElementById("toast").classList.add("on");
            },
            cf.an === "fly" ? 450 : 300,
          ),
        );
        if (!G._endSent && NET.mode !== "bot" && NET.conn) {
          G._endSent = true;
          netSend({ type: "gameover", reason, winner });
        }
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // CONFIRM / MSG
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function showConfirm(ti, su, ok) {
        document.getElementById("cfTi").textContent = ti;
        document.getElementById("cfSu").textContent = su;
        document.getElementById("confModal").classList.add("on");
        document.getElementById("cfYes").onclick = () => {
          document.getElementById("confModal").classList.remove("on");
          ok();
        };
        document.getElementById("cfNo").onclick = () =>
          document.getElementById("confModal").classList.remove("on");
      }
      function showMsg(ti, su) {
        document.getElementById("tTi").textContent = ti;
        document.getElementById("tSu").textContent = su;
        const tr3 = document.getElementById("tRematch");
        if (tr3) tr3.style.display = "none";
        const t = document.getElementById("toast");
        t.classList.add("on");
        setTimeout(() => t.classList.remove("on"), 3200);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // COLLAPSIBLE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      [
        ["hS", "bS"],
        ["hR", "bR"],
        ["hM", "bM"],
        ["hB", "bB"],
        ["hV", "bV"],
        ["hRu", "bRu"],
        ["hElo", "bElo"],
      ].forEach(([hi, bi]) => {
        const h = document.getElementById(hi),
          b = document.getElementById(bi);
        if (h && b)
          h.addEventListener("click", () => {
            const cl = b.classList.toggle("cl");
            h.classList.toggle("cl", cl);
          });
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // LEVEL
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function setLevel(n) {
        botLevel = n;
        document
          .querySelectorAll(".lb,.mpl")
          .forEach((b) =>
            b.classList.toggle("on", parseInt(b.dataset.l) === n),
          );
        if (!G.over && NET.mode === "bot") newGame();
      }
      document
        .querySelectorAll(".lb,.mpl")
        .forEach((b) =>
          b.addEventListener("click", () => setLevel(parseInt(b.dataset.l))),
        );

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // GAME ACTIONS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function doResign() {
        if (G.over) return;
        if (NET.mode !== "bot") {
          showConfirm("Resign?", "Your opponent wins.", () => {
            netSend({ type: "resign" });
            endGame("resign", opp(NET.myCol));
          });
          return;
        }
        if (G.turn !== "w") return;
        showConfirm("Resign?", "Are you sure?", () => endGame("resign", "b"));
      }
      function doDraw() {
        if (G.over) return;
        if (NET.mode !== "bot") {
          netSend({ type: "draw_offer" });
          showMsg("Draw Offered", "Waiting for opponent‚Ä¶");
          return;
        }
        const ev = -evalBoard(G.brd);
        const evStr = (ev / 100).toFixed(1);
        if (ev > 200)
          showMsg("Declined", `Bot is winning (${evStr}) ‚Äî won't accept.`);
        else if (ev > 50)
          showMsg("Declined", `Bot has the edge (${evStr}) ‚Äî declined.`);
        else
          showConfirm("Draw Offer", `Bot accepts (eval ${evStr}).`, () =>
            endGame("draw", ""),
          );
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // LOCAL TIME MODAL
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function buildLocalTimePicker() {
        const el = document.getElementById("localTPicker");
        el.innerHTML = "";
        TIME_CTRLS.forEach((tc, i) => {
          const b = document.createElement("button");
          b.className = "tpill" + (localSelectedTC === i ? " on" : "");
          b.textContent = tc.l;
          b.addEventListener("click", () => {
            localSelectedTC = i;
            document
              .querySelectorAll("#localTPicker .tpill")
              .forEach((p, j) => p.classList.toggle("on", j === i));
          });
          el.appendChild(b);
        });
      }
      function openLocalTimeModal(cb) {
        buildLocalTimePicker();
        document.getElementById("localTimeModal").classList.add("on");
        document.getElementById("localTimeOk").onclick = () => {
          document.getElementById("localTimeModal").classList.remove("on");
          if (localSelectedTC !== null) cb(TIME_CTRLS[localSelectedTC]);
          else cb(null);
        };
        document.getElementById("localTimeNoTimer").onclick = () => {
          document.getElementById("localTimeModal").classList.remove("on");
          cb(null);
        };
        document.getElementById("localTimeCancel").onclick = () => {
          document.getElementById("localTimeModal").classList.remove("on");
        };
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // DRAWINGS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const DRAW = { shapes: [], dragFrom: null, color: "#f6a623" };
      const DRAW_COLORS = ["#f6a623", "#4a9eff", "#e53935", "#4caf50"];
      let _drawColorIdx = 0;
      function sqCenter(r, c) {
        const board = document.getElementById("board"),
          svg = document.getElementById("drawSvg");
        if (!board || !svg) return { x: 0, y: 0 };
        const bRect = board.getBoundingClientRect(),
          sRect = svg.parentElement.getBoundingClientRect();
        const sqW = bRect.width / 8,
          sqH = bRect.height / 8;
        const bx = bRect.left - sRect.left,
          by = bRect.top - sRect.top;
        return { x: bx + (c + 0.5) * sqW, y: by + (r + 0.5) * sqH };
      }
      function sqFromBoardXY(cx, cy) {
        const board = document.getElementById("board");
        if (!board) return null;
        const rect = board.getBoundingClientRect();
        const c = Math.floor((cx - rect.left) / (rect.width / 8)),
          r = Math.floor((cy - rect.top) / (rect.height / 8));
        if (r < 0 || r >= 8 || c < 0 || c >= 8) return null;
        return { r, c };
      }
      function drawArrow(svg, x1, y1, x2, y2, color) {
        const dx = x2 - x1,
          dy = y2 - y1,
          len = Math.sqrt(dx * dx + dy * dy);
        if (len < 10) return;
        const board = document.getElementById("board"),
          sqW = board ? board.getBoundingClientRect().width / 8 : 60;
        const hw = sqW * 0.17,
          hl = sqW * 0.28,
          sw = sqW * 0.085,
          ux = dx / len,
          uy = dy / len;
        const ex = x2 - ux * hl * 0.5,
          ey = y2 - uy * hl * 0.5;
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.setAttribute("opacity", "0.82");
        const line = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line",
        );
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", ex);
        line.setAttribute("y2", ey);
        line.setAttribute("stroke", color);
        line.setAttribute("stroke-width", sw);
        line.setAttribute("stroke-linecap", "round");
        g.appendChild(line);
        const px = -uy * hw,
          py = ux * hw,
          pts = `${x2},${y2} ${ex + px},${ey + py} ${ex - px},${ey - py}`;
        const poly = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "polygon",
        );
        poly.setAttribute("points", pts);
        poly.setAttribute("fill", color);
        g.appendChild(poly);
        svg.appendChild(g);
      }
      function drawCircle(svg, x, y, color) {
        const board = document.getElementById("board"),
          sqW = board ? board.getBoundingClientRect().width / 8 : 60;
        const r = sqW * 0.42,
          sw = sqW * 0.075;
        const c = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle",
        );
        c.setAttribute("cx", x);
        c.setAttribute("cy", y);
        c.setAttribute("r", r);
        c.setAttribute("fill", "none");
        c.setAttribute("stroke", color);
        c.setAttribute("stroke-width", sw);
        c.setAttribute("opacity", "0.82");
        svg.appendChild(c);
      }
      function renderDrawings() {
        const svg = document.getElementById("drawSvg");
        if (!svg) return;
        svg.innerHTML = "";
        for (const s of DRAW.shapes) {
          const from = sqCenter(s.r1, s.c1);
          if (s.type === "circle") drawCircle(svg, from.x, from.y, s.color);
          else {
            const to = sqCenter(s.r2, s.c2);
            drawArrow(svg, from.x, from.y, to.x, to.y, s.color);
          }
        }
        if (DRAW.dragFrom && DRAW._curX !== undefined) {
          const from = sqCenter(DRAW.dragFrom.r, DRAW.dragFrom.c);
          drawArrow(
            svg,
            from.x,
            from.y,
            DRAW._curX,
            DRAW._curY,
            DRAW.color + "aa",
          );
        }
      }
      function clearDrawings() {
        DRAW.shapes = [];
        renderDrawings();
      }
      const boardEl2 = document.getElementById("board");
      boardEl2.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      // Right-click cancels premove (chess.com behaviour)
      boardEl2.addEventListener(
        "mousedown",
        (e) => {
          if (e.button !== 2) return;
          if (PMQUEUE.length || PMSEL) {
            pmClear();
          }
        },
        { passive: true },
      );
      boardEl2.addEventListener(
        "mousedown",
        (e) => {
          if (e.button !== 2) return;
          e.preventDefault();
          if (NET.mode === "host" || NET.mode === "guest") return; // no drawings in online mode
          const sq = sqFromBoardXY(e.clientX, e.clientY);
          if (!sq) return;
          DRAW.dragFrom = { ...sq };
          DRAW._curX = undefined;
        },
        { passive: false },
      );
      document.addEventListener("mousemove", (e) => {
        if (!DRAW.dragFrom) return;
        const svg = document.getElementById("drawSvg");
        if (!svg) return;
        const sRect = svg.parentElement.getBoundingClientRect();
        DRAW._curX = e.clientX - sRect.left;
        DRAW._curY = e.clientY - sRect.top;
        renderDrawings();
      });
      document.addEventListener("mouseup", (e) => {
        if (e.button !== 2) return;
        if (!DRAW.dragFrom) return;
        const sq = sqFromBoardXY(e.clientX, e.clientY),
          from = DRAW.dragFrom;
        DRAW.dragFrom = null;
        DRAW._curX = undefined;
        if (!sq) {
          renderDrawings();
          return;
        }
        const isSame = sq.r === from.r && sq.c === from.c;
        if (isSame) {
          const idx = DRAW.shapes.findIndex(
            (s) =>
              s.type === "circle" &&
              s.r1 === sq.r &&
              s.c1 === sq.c &&
              s.color === DRAW.color,
          );
          if (idx >= 0) DRAW.shapes.splice(idx, 1);
          else
            DRAW.shapes.push({
              type: "circle",
              r1: sq.r,
              c1: sq.c,
              color: DRAW.color,
            });
        } else {
          const idx = DRAW.shapes.findIndex(
            (s) =>
              s.type === "arrow" &&
              s.r1 === from.r &&
              s.c1 === from.c &&
              s.r2 === sq.r &&
              s.c2 === sq.c &&
              s.color === DRAW.color,
          );
          if (idx >= 0) DRAW.shapes.splice(idx, 1);
          else
            DRAW.shapes.push({
              type: "arrow",
              r1: from.r,
              c1: from.c,
              r2: sq.r,
              c2: sq.c,
              color: DRAW.color,
            });
        }
        renderDrawings();
        // Sync drawings to opponent
        if (NET.mode === "host" || NET.mode === "guest")
          netSend({ type: "drawings", shapes: DRAW.shapes });
      });
      boardEl2.addEventListener("click", (e) => {
        if (DRAW.shapes.length > 0 && !DR.on) {
          clearDrawings();
          if (NET.mode === "host" || NET.mode === "guest")
            netSend({ type: "drawings", shapes: [] });
        }
      });
      boardEl2.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length !== 2) return;
          e.preventDefault();
          clearDrawings();
          if (NET.mode === "host" || NET.mode === "guest")
            netSend({ type: "drawings", shapes: [] });
        },
        { passive: false },
      );
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          clearDrawings();
          if (NET.mode === "host" || NET.mode === "guest")
            netSend({ type: "drawings", shapes: [] });
        }
        if (e.key === "ArrowRight") {
          _drawColorIdx = (_drawColorIdx + 1) % DRAW_COLORS.length;
          DRAW.color = DRAW_COLORS[_drawColorIdx];
        }
        // Backspace: usu≈Ñ ostatni krok pre-move
        if (e.key === "Backspace" && !isMyTurn() && (PMQUEUE.length || PMSEL)) {
          e.preventDefault();
          if (PMSEL) {
            PMSEL = null;
            render();
            return;
          }
          PMQUEUE.pop();
          pmSync();
          if (PMQUEUE.length) {
            const last = PMQUEUE[PMQUEUE.length - 1];
            PMSEL = {
              fr: last.tr,
              fc: last.tc,
              poss: premovePoss(last.tr, last.tc, last.brd, myColor()),
              brd: last.brd,
            };
          }
          render();
        }
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // BUTTON WIRING
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      document.getElementById("newBtn").addEventListener("click", () => {
        if (!animOn && NET.mode === "bot") newGame();
      });
      document.getElementById("flipBtn").addEventListener("click", () => {
        flipped = !flipped;
        render();
      });
      document.getElementById("resignBtn").addEventListener("click", doResign);
      document.getElementById("drawBtn").addEventListener("click", doDraw);
      document.getElementById("mFlip").addEventListener("click", () => {
        flipped = !flipped;
        render();
      });
      document.getElementById("mNew").addEventListener("click", () => {
        if (NET.mode === "bot") {
          newGame();
        } else if (NET.mode === "local") {
          openLocalTimeModal((tc) => {
            NET.timeCtrl = tc || null;
            newGame(tc);
          });
        }
      });
      document.getElementById("mRes").addEventListener("click", doResign);
      document.getElementById("mDrw").addEventListener("click", doDraw);
      document.getElementById("tNew").addEventListener("click", () => {
        document.getElementById("toast").classList.remove("on");
        if (NET.mode === "bot") newGame();
        else if (NET.mode === "local")
          openLocalTimeModal((tc) => {
            NET.timeCtrl = tc || null;
            newGame(tc);
          });
      });
      document.getElementById("tRematch").addEventListener("click", () => {
        document.getElementById("toast").classList.remove("on");
        if (NET.mode !== "bot" && P.conn) {
          netSend({ type: "rematch_offer" });
          showMsg("Rematch", "Waiting for opponent‚Ä¶");
        }
      });
      document.getElementById("newBtn").addEventListener("click", () => {
        if (NET.mode === "local")
          openLocalTimeModal((tc) => {
            NET.timeCtrl = tc || null;
            newGame(tc);
          });
        else if (!animOn && NET.mode === "bot") newGame();
      });
      document
        .getElementById("togEval")
        .addEventListener("change", function () {
          NET.showEval = this.checked;
          document.getElementById("evbar").style.display = this.checked
            ? ""
            : "none";
          const mev = document.getElementById("mEv");
          if (mev) mev.style.display = this.checked ? "" : "none";
        });
      document
        .getElementById("togRating")
        .addEventListener("change", function () {
          NET.showRating = this.checked;
          const rCard = document.getElementById("bR");
          if (rCard && rCard.parentElement)
            rCard.parentElement.style.display = this.checked ? "" : "none";
        });
      document
        .getElementById("togLocal")
        .addEventListener("change", function () {
          if (NET.mode === "host" || NET.mode === "guest") {
            this.checked = false;
            return;
          }
          if (this.checked) {
            NET.mode = "local";
            NET.myCol = "w";
            flipped = false;
            _botAbort = true;
            const bc = document.getElementById("hB");
            if (bc && bc.parentElement) bc.parentElement.style.display = "none";
            const mpls = document.getElementById("mBotLvls");
            if (mpls) mpls.style.display = "none";
            const ml = document.getElementById("mLocal");
            if (ml) ml.classList.add("on");
            openLocalTimeModal((tc) => {
              NET.timeCtrl = tc || null;
              newGame(tc);
            });
          } else {
            NET.mode = "bot";
            NET.myCol = "w";
            const bc = document.getElementById("hB");
            if (bc && bc.parentElement) bc.parentElement.style.display = "";
            const mpls = document.getElementById("mBotLvls");
            if (mpls) mpls.style.display = "flex";
            const ml = document.getElementById("mLocal");
            if (ml) ml.classList.remove("on");
            newGame();
          }
        });
      document.getElementById("mOnline2").addEventListener("click", openLobby);
      document.getElementById("mLocal").addEventListener("click", () => {
        if (NET.mode === "host" || NET.mode === "guest") return;
        const tog = document.getElementById("togLocal");
        tog.checked = !tog.checked;
        tog.dispatchEvent(new Event("change"));
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ONLINE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let P = { peer: null, conn: null, role: "", roomId: "" };
      let lobbyRole = "",
        guestJoined = false,
        guestName = "",
        guestElo = 500;
      function genId(n = 8) {
        let s = "";
        while (s.length < n) s += Math.random().toString(36).substr(2);
        return s.substr(0, n).toUpperCase();
      }
      function lstat(t) {
        const e = document.getElementById("lCStat");
        if (e) e.textContent = t;
      }
      function lmsg(t) {
        const e = document.getElementById("lMsg");
        if (e) e.textContent = t;
      }
      function netSend(d) {
        try {
          if (P.conn && P.conn.open) P.conn.send(d);
        } catch (e) {}
      }
      function closePeer() {
        try {
          P.conn && P.conn.close();
        } catch (e) {}
        try {
          P.peer && P.peer.destroy();
        } catch (e) {}
        P = { peer: null, conn: null, role: P.role, roomId: "" };
      }
      function loadPeerJS(cb) {
        if (window.Peer) {
          cb();
          return;
        }
        const s = document.createElement("script");
        s.src = "https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js";
        s.onload = cb;
        s.onerror = () => lstat("Failed to load PeerJS.");
        document.head.appendChild(s);
      }
      function hostFlow(roomId) {
        P.role = "host";
        P.roomId = roomId;
        lstat("Setting up room...");
        loadPeerJS(() => {
          P.peer = new Peer(roomId, { debug: 0 });
          P.peer.on("error", (err) => {
            if (err.type === "unavailable-id") hostFlow(genId(8));
            else lstat("Error: " + err.type);
          });
          P.peer.on("open", (id) => {
            lstat("Waiting for guest...");
            const url = location.href.split("?")[0] + "?room=" + id;
            document.getElementById("lLinkLabel").textContent =
              "üîó Invite link ‚Äî click to copy:";
            document.getElementById("lobbyLink").textContent = url;
            document.getElementById("lLinkSec").style.display = "";
          });
          P.peer.on("connection", (conn) => {
            P.conn = conn;
            setupDC(conn, "host");
          });
        });
      }
      function guestFlow(roomId) {
        P.role = "guest";
        P.roomId = roomId;
        lstat("Connecting to host...");
        loadPeerJS(() => {
          P.peer = new Peer(undefined, { debug: 0 });
          P.peer.on("error", (err) =>
            lstat("Error: " + err.type + ". Check the link or try again."),
          );
          P.peer.on("open", () => {
            lstat("Reaching host...");
            const conn = P.peer.connect(roomId, {
              reliable: true,
              label: "chess",
            });
            P.conn = conn;
            setupDC(conn, "guest");
          });
        });
      }
      function setupDC(conn, role) {
        conn.on("open", () => {
          lstat("Connected!");
          lmsg("");
          conn.send({ type: "hello", name: getMyName(), elo: eloGet() });
          if (role === "host") {
            guestJoined = true;
            document.getElementById("lpGuestSt").textContent = "Connected!";
            document.getElementById("lpGuest").classList.add("joined");
            document.getElementById("lKick").style.display = "";
            document.getElementById("lTimeSec").style.display = "";
            lmsg("Guest connected! Choose time control, then start.");
            if (selectedTC !== null)
              document.getElementById("lStart").style.display = "";
          } else lstat("Connected! Waiting for host to start...");
        });
        conn.on("data", (d) => {
          if (!NET.gameStarted) handleLobbyMsg(d, role);
          else handleGameMsg(d);
        });
        conn.on("close", () => {
          if (!NET.gameStarted) lstat("Connection closed.");
        });
        conn.on("error", () => {
          if (!NET.gameStarted) lstat("Connection error.");
        });
      }
      function handleLobbyMsg(d, myRole) {
        if (d.type === "hello") {
          if (myRole === "host") {
            guestName = d.name;
            guestElo = d.elo || 500;
            document.getElementById("lpGuestNm").textContent = d.name;
          } else {
            document.getElementById("lpHostNm").textContent = d.name;
          }
        }
        if (d.type === "kick") {
          lmsg("You were kicked.");
          closePeer();
          document.getElementById("lobby").classList.remove("on");
        }
        if (d.type === "start_game") startOnlineGame(d, myRole);
      }
      function getMyName() {
        return document.getElementById("lobbyName").value.trim() || "Player";
      }
      function resolveNames(h, g) {
        let hn = h || "Player",
          gn = g || "Player";
        if (hn === gn) {
          hn = "Player 1";
          gn = "Player 2";
        }
        return { h: hn, g: gn };
      }
      function buildTimePicker() {
        const el = document.getElementById("tPicker");
        el.innerHTML = "";
        TIME_CTRLS.forEach((tc, i) => {
          const b = document.createElement("button");
          b.className = "tpill" + (selectedTC === i ? " on" : "");
          b.textContent = tc.l;
          b.addEventListener("click", () => {
            selectedTC = i;
            document
              .querySelectorAll(".tpill")
              .forEach((p, j) => p.classList.toggle("on", j === i));
            if (guestJoined)
              document.getElementById("lStart").style.display = "";
          });
          el.appendChild(b);
        });
      }
      function openLobby() {
        document.getElementById("lobby").classList.add("on");
        lstat("");
        lmsg("");
        ["lLinkSec", "lTimeSec", "lStart"].forEach((id) => {
          const e = document.getElementById(id);
          if (e) e.style.display = "none";
        });
        document.getElementById("lpGuestNm").textContent = "Waiting‚Ä¶";
        document.getElementById("lpGuestSt").textContent = "No one yet";
        document.getElementById("lpGuest").classList.remove("joined");
        document.getElementById("lKick").style.display = "none";
        guestJoined = false;
        closePeer();
        const room = new URLSearchParams(location.search).get("room");
        if (room) {
          lobbyRole = "guest";
          document.getElementById("lpGuestNm").textContent = getMyName();
          document.getElementById("lpGuest").classList.add("joined");
          document.getElementById("lpGuestSt").textContent = "You";
          document.getElementById("lpHostNm").textContent = "Host";
          const os = document.getElementById("lOptsSec");
          if (os) os.style.display = "none";
          guestFlow(room);
        } else {
          lobbyRole = "host";
          document.getElementById("lpHostNm").textContent = getMyName();
          buildTimePicker();
          hostFlow(genId(8));
        }
      }
      function startOnlineGame(cfg, myRole) {
        document.getElementById("lobby").classList.remove("on");
        try {
          history.replaceState({}, "", location.pathname);
        } catch (e) {}
        const nm = resolveNames(cfg.hostName, cfg.guestName);
        NET.mode = myRole;
        NET.myCol = myRole === "host" ? "w" : "b";
        NET.myName = myRole === "host" ? nm.h : nm.g;
        NET.oppName = myRole === "host" ? nm.g : nm.h;
        NET.myElo = eloGet();
        NET.oppElo =
          myRole === "host" ? cfg.guestElo || 500 : cfg.hostElo || 500;
        NET.showEval = cfg.showEval;
        NET.showRating = cfg.showRating;
        NET.timeCtrl = cfg.timeCtrl || null;
        NET.rematchTime = cfg.timeCtrl || null;
        NET.conn = P.conn;
        NET.gameStarted = true;
        const te = document.getElementById("togEval");
        if (te) te.checked = cfg.showEval;
        const tr = document.getElementById("togRating");
        if (tr) tr.checked = cfg.showRating;
        flipped = myRole === "guest";
        const bc = document.getElementById("hB");
        if (bc && bc.parentElement) bc.parentElement.style.display = "none";
        document.getElementById("newBtn").style.display = "none";
        newGame(cfg.timeCtrl);
        if (cfg.timeCtrl && myRole === "host") startTurnTimer("w");
        eloShowOnlinePinfo();
      }
      function handleGameMsg(d) {
        if (d.type === "move") {
          if (d.timers) {
            // Sync timers precisely ‚Äî use network timestamps
            NET.timers = d.timers;
          }
          if (d.castl) G.castl = { ...d.castl };
          // Basic sanity check: piece must exist and belong to current turn
          const netPiece = G.brd[d.mv.fr] && G.brd[d.mv.fr][d.mv.fc];
          if (!netPiece || netPiece[0] !== G.turn) {
            console.warn(
              "Rejected move from network ‚Äî wrong piece:",
              d.mv,
              netPiece,
            );
            return;
          }
          // Sync eval and rating from sender
          playMove(d.mv, false, true)
            .then?.(() => {})
            .catch?.(() => {});
          // Use eval from sender directly ‚Äî single source of truth
          if (d.eval !== undefined && NET.showEval) {
            setTimeout(() => {
              setEval(d.eval);
              // Echo back so both sides are guaranteed identical
              netSend({ type: "eval_sync", ev: d.eval });
            }, 15);
          }
          // Override displayed rating with sender's computed value (same analysis)
          if (d.ri !== undefined && NET.showRating) {
            const R = RTNG[d.ri] || RTNG[RTNG.length - 1];
            document.getElementById("ratingEl").innerHTML =
              `<span class="${R.c}">${R.s} ${R.l}</span><span style="color:var(--dim);font-size:.65rem"> (opp)</span>`;
            document.getElementById("mRt").innerHTML =
              `<span class="${R.c}">${R.s}</span>`;
          }
        }
        // promo is now included in the move packet (mv.promo) ‚Äî no separate handler needed
        if (d.type === "drawings") {
          DRAW.shapes = d.shapes || [];
          renderDrawings();
        }
        if (d.type === "eval_sync") {
          if (NET.showEval) setEval(d.ev);
        }
        if (d.type === "gameover") {
          if (!G.over) endGame(d.reason, d.winner);
        }
        if (d.type === "resign") endGame("resign", NET.myCol);
        if (d.type === "draw_offer") {
          const banner = document.getElementById("drawOfferBanner");
          document.getElementById("drawOfferText").textContent =
            NET.oppName + " offers a draw";
          banner.style.display = "flex";
          document.getElementById("drawAcceptBtn").onclick = () => {
            banner.style.display = "none";
            netSend({ type: "draw_accept" });
            endGame("draw", "");
          };
          document.getElementById("drawDeclineBtn").onclick = () => {
            banner.style.display = "none";
            netSend({ type: "draw_decline" });
          };
        }
        if (d.type === "draw_accept") endGame("draw", "");
        if (d.type === "draw_decline")
          showMsg("Draw Declined", NET.oppName + " declined the draw.");
        if (d.type === "rematch_offer")
          showConfirm("Rematch?", NET.oppName + " wants a rematch.", () => {
            netSend({ type: "rematch_accept" });
            doRematch();
          });
        if (d.type === "rematch_accept") doRematch();
        if (d.type === "timer_sync") NET.timers = d.timers; // precise timer sync
      }
      function doRematch() {
        document.getElementById("toast").classList.remove("on");
        flipped = NET.myCol === "b";
        newGame(NET.rematchTime);
        if (NET.rematchTime && NET.myCol === "w") startTurnTimer("w");
        eloShowOnlinePinfo();
      }
      document.getElementById("lKick").addEventListener("click", () => {
        netSend({ type: "kick" });
        guestJoined = false;
        document.getElementById("lpGuestNm").textContent = "Waiting‚Ä¶";
        document.getElementById("lpGuestSt").textContent = "No one yet";
        document.getElementById("lpGuest").classList.remove("joined");
        ["lKick", "lTimeSec", "lStart"].forEach(
          (id) => (document.getElementById(id).style.display = "none"),
        );
        lmsg("Guest kicked.");
      });
      document.getElementById("lStart").addEventListener("click", () => {
        if (!guestJoined) {
          lmsg("Wait for guest to join!");
          return;
        }
        if (selectedTC === null) {
          lmsg("Choose a time control!");
          return;
        }
        const cfg = {
          type: "start_game",
          hostName: getMyName(),
          guestName,
          hostElo: eloGet(),
          guestElo,
          showEval: document.getElementById("optEval").checked,
          showRating: document.getElementById("optRating").checked,
          timeCtrl: TIME_CTRLS[selectedTC],
        };
        netSend(cfg);
        startOnlineGame(cfg, "host");
      });
      document.getElementById("lClose").addEventListener("click", () => {
        document.getElementById("lobby").classList.remove("on");
        try {
          history.replaceState({}, "", location.pathname);
        } catch (e) {}
        if (!NET.gameStarted) closePeer();
      });
      document.getElementById("onlineBtn").addEventListener("click", openLobby);
      document
        .getElementById("mOnlineBtn")
        .addEventListener("click", openLobby);
      document.getElementById("lobbyLink").addEventListener("click", () => {
        const txt = document.getElementById("lobbyLink").textContent;
        navigator.clipboard
          .writeText(txt)
          .then(() => {
            const e = document.getElementById("lCopyMsg");
            if (e) {
              e.textContent = "‚úì Skopiowano!";
              e.style.color = "var(--grn)";
              setTimeout(() => (e.textContent = ""), 2500);
            }
          })
          .catch(() => {
            const r = document.createRange();
            r.selectNode(document.getElementById("lobbyLink"));
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(r);
          });
      });
      document.getElementById("lobbyName").addEventListener("input", () => {
        const el = document.getElementById(
          lobbyRole === "host" ? "lpHostNm" : "lpGuestNm",
        );
        if (el) el.textContent = getMyName() || "Player";
      });
      if (new URLSearchParams(location.search).get("room")) openLobby();

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // SOUNDS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const _AC = new (window.AudioContext || window.webkitAudioContext)();
      function _resume() {
        if (_AC.state === "suspended") _AC.resume();
      }

      // Low time tick (chess.com style)
      let _lastTickTime = 0;
      function playLowTimeTick() {
        _resume();
        const t = _AC.currentTime;
        const o = _AC.createOscillator(),
          g = _AC.createGain();
        o.connect(g);
        g.connect(_AC.destination);
        o.type = "square";
        o.frequency.setValueAtTime(800, t);
        g.gain.setValueAtTime(0.12, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        o.start(t);
        o.stop(t + 0.06);
      }

      function playSound(type) {
        _resume();
        const t = _AC.currentTime;
        const o = _AC.createOscillator(),
          g = _AC.createGain();
        o.connect(g);
        g.connect(_AC.destination);
        if (type === "move") {
          o.type = "sine";
          o.frequency.setValueAtTime(520, t);
          o.frequency.exponentialRampToValueAtTime(440, t + 0.06);
          g.gain.setValueAtTime(0.18, t);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
          o.start(t);
          o.stop(t + 0.12);
        } else if (type === "capture") {
          o.type = "sawtooth";
          o.frequency.setValueAtTime(300, t);
          o.frequency.exponentialRampToValueAtTime(120, t + 0.18);
          g.gain.setValueAtTime(0.22, t);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
          o.start(t);
          o.stop(t + 0.18);
        } else if (type === "check") {
          const o2 = _AC.createOscillator(),
            g2 = _AC.createGain();
          o2.connect(g2);
          g2.connect(_AC.destination);
          o.type = "square";
          o.frequency.setValueAtTime(880, t);
          g.gain.setValueAtTime(0.15, t);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
          o.start(t);
          o.stop(t + 0.1);
          o2.type = "square";
          o2.frequency.setValueAtTime(660, t + 0.12);
          g2.gain.setValueAtTime(0.15, t + 0.12);
          g2.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
          o2.start(t + 0.12);
          o2.stop(t + 0.22);
        } else if (type === "castle") {
          o.type = "sine";
          o.frequency.setValueAtTime(440, t);
          o.frequency.exponentialRampToValueAtTime(660, t + 0.08);
          o.frequency.exponentialRampToValueAtTime(550, t + 0.16);
          g.gain.setValueAtTime(0.2, t);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
          o.start(t);
          o.stop(t + 0.2);
        } else if (type === "gameover") {
          o.type = "sine";
          o.frequency.setValueAtTime(440, t);
          o.frequency.exponentialRampToValueAtTime(220, t + 0.5);
          g.gain.setValueAtTime(0.25, t);
          g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
          o.start(t);
          o.stop(t + 0.5);
        }
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ELO SYSTEM
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const ELO_KEY = "controlchess_elo";
      const ELO_HIST_KEY = "controlchess_elo_hist";

      function eloGet() {
        return parseInt(localStorage.getItem(ELO_KEY) || "500");
      }
      function eloSet(v) {
        localStorage.setItem(ELO_KEY, String(Math.max(0, Math.round(v))));
      }
      function eloHistGet() {
        try {
          return JSON.parse(localStorage.getItem(ELO_HIST_KEY) || "[]");
        } catch {
          return [];
        }
      }
      function eloHistPush(entry) {
        const h = eloHistGet();
        h.unshift(entry);
        if (h.length > 10) h.pop();
        localStorage.setItem(ELO_HIST_KEY, JSON.stringify(h));
      }

      const ELO_MOVE_DELTA = {
        "Genius!!!": +6,
        "Brilliant!!": +5,
        "Great!": +3,
        Best: +2,
        Excellent: +1,
        Good: 0,
        Book: 0,
        Okay: 0,
        Inaccuracy: -1,
        Mistake: -3,
        Blunder: -6,
        Catastrophe: -10,
        Losing: -15,
      };

      function eloGameDelta(reason, winner, myCol) {
        const iWon = winner === myCol,
          isDraw = !winner || winner === "";
        if (isDraw) return +3;
        if (reason === "checkmate" && iWon) return +25;
        if (reason === "checkmate" && !iWon) return -20;
        if (reason === "timeout" && iWon) return +15;
        if (reason === "timeout" && !iWon) return -12;
        if (reason === "resign" && iWon) return +18;
        if (reason === "resign" && !iWon) return -15;
        if (reason === "stalemate") return +2;
        return iWon ? +12 : -10;
      }

      // Per-game accumulators (reset each new game)
      let _eloMoveDeltaAccum = 0; // sum of move deltas this game
      let _eloMoveLog = []; // [{label, d}] for breakdown display
      let _eloEligible = false; // whether ELO applies this game

      function eloGameStart() {
        _eloMoveDeltaAccum = 0;
        _eloMoveLog = [];
        _eloEligible =
          (NET.mode === "bot" && botLevel >= 4) ||
          NET.mode === "host" ||
          NET.mode === "guest";
        // Reset toast breakdown
        const te = document.getElementById("tEloResult");
        if (te) te.style.display = "none";
        const tb = document.getElementById("tEloBreakdown");
        if (tb) tb.style.display = "none";
        // Reset sidebar live counter
        const ch = document.getElementById("eloChange");
        if (ch) ch.textContent = "";
      }

      function eloOnMove(ri) {
        if (!_eloEligible || ri === null || ri === undefined) return;
        const label = RTNG[ri]?.l || "";
        const d = ELO_MOVE_DELTA[label] ?? 0;
        if (d === 0) return;
        _eloMoveDeltaAccum += d;
        _eloMoveLog.push({ label, d });
        // Update sidebar live
        eloDisplay();
      }

      function eloOnGame(reason, winner) {
        if (!_eloEligible) return;
        const myCol = NET.mode === "bot" ? "w" : NET.myCol || "w";
        const gameDelta = eloGameDelta(reason, winner, myCol);
        const totalDelta = _eloMoveDeltaAccum + gameDelta;
        const before = eloGet();
        const after = Math.max(0, before + totalDelta);
        eloSet(after);

        // Build history entry
        const resultLabel =
          winner === myCol
            ? "Wygrana"
            : !winner || winner === ""
              ? "Remis"
              : "Przegrana";
        const sign = totalDelta >= 0 ? "+" : "";
        const oppName =
          NET.mode === "bot" ? `Bot L${botLevel}` : NET.oppName || "Przeciwnik";
        const entry = {
          date: new Date().toLocaleDateString("pl"),
          result: resultLabel,
          opp: oppName,
          before,
          after,
          total: totalDelta,
          gameDelta,
          moveDelta: _eloMoveDeltaAccum,
          moveLog: [..._eloMoveLog],
        };
        eloHistPush(entry);

        // Show breakdown in toast
        eloShowToastResult(entry);
        eloDisplay();
        eloRenderHistory();
      }

      function eloShowToastResult(entry) {
        const er = document.getElementById("tEloResult");
        const eb = document.getElementById("tEloBreakdown");
        if (!er || !eb) return;
        const sign = entry.total >= 0 ? "+" : "";
        er.textContent = `ELO: ${entry.before} ‚Üí ${entry.after} (${sign}${entry.total})`;
        er.style.display = "block";
        er.style.color = entry.total >= 0 ? "#81c784" : "#e57373";

        // Build breakdown lines
        const lines = [];
        const gs = entry.gameDelta >= 0 ? "+" : "";
        const rs =
          entry.result === "Wygrana"
            ? "üèÜ"
            : entry.result === "Remis"
              ? "ü§ù"
              : "üíÄ";
        lines.push(`${rs} Wynik: ${gs}${entry.gameDelta}`);
        if (entry.moveDelta !== 0) {
          const ms = entry.moveDelta >= 0 ? "+" : "";
          lines.push(`‚ôü Ruchy: ${ms}${entry.moveDelta}`);
          // Show worst/best moves
          const bests = entry.moveLog.filter((m) => m.d > 0).slice(0, 3);
          const bads = entry.moveLog.filter((m) => m.d < 0).slice(0, 3);
          bests.forEach((m) => lines.push(`  ‚úì ${m.label}: +${m.d}`));
          bads.forEach((m) => lines.push(`  ‚úó ${m.label}: ${m.d}`));
        }
        eb.innerHTML = lines
          .map((l) => `<div style="padding:1px 0">${l}</div>`)
          .join("");
        eb.style.display = "block";
      }

      function eloDisplay() {
        const el = document.getElementById("eloVal");
        if (el) el.textContent = eloGet();
        const ch = document.getElementById("eloChange");
        if (ch && _eloMoveDeltaAccum !== 0) {
          const s = _eloMoveDeltaAccum >= 0 ? "+" : "";
          ch.textContent = `Ruchy: ${s}${_eloMoveDeltaAccum} (ta partia)`;
          ch.style.color = _eloMoveDeltaAccum >= 0 ? "#81c784" : "#e57373";
        }
      }

      function eloRenderHistory() {
        const el = document.getElementById("eloHistory");
        if (!el) return;
        const h = eloHistGet();
        el.innerHTML = h
          .map((e) => {
            if (typeof e === "string")
              return `<div style="padding:1px 0;border-bottom:1px solid rgba(255,255,255,.05)">${e}</div>`;
            return `<div style="padding:2px 0;border-bottom:1px solid rgba(255,255,255,.05)">
      <span style="color:var(--dim)">${e.result} vs ${e.opp} ¬∑ ${e.date} ¬∑ </span><span style="color:${e.total >= 0 ? "#81c784" : "#e57373"}">${e.before}‚Üí${e.after}</span>
    </div>`;
          })
          .join("");
      }

      function eloShowOnlinePinfo() {
        if (NET.mode !== "host" && NET.mode !== "guest") return;
        const botEl = document.getElementById("eloBot");
        const topEl = document.getElementById("eloTop");
        if (botEl) {
          botEl.textContent = `ELO: ${eloGet()}`;
          botEl.style.display = "block";
        }
        if (topEl) {
          topEl.textContent = `ELO: ${NET.oppElo || "?"}`;
          topEl.style.display = "block";
        }
      }

      function eloInit() {
        const el = document.getElementById("eloVal");
        if (el) el.textContent = eloGet();
        const te = document.getElementById("tEloResult");
        if (te) te.style.display = "none";
        const tb = document.getElementById("tEloBreakdown");
        if (tb) tb.style.display = "none";
        eloRenderHistory();
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // INIT
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      newGame();
      eloInit();
    </script>
  </body>
</html>
